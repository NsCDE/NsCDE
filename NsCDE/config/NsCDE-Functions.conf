#
# This file is a part of the NsCDE - Not so Common Desktop Environment
# Author: Hegel3DReloaded
# Licence: GPLv3
#

#################################
# Core Window Operation Functions
#################################

# Function: f_GotoDeskAndPage
# Parameters:
# $[*] - desk numbers for child dependent functions
# Changes active Workspace and page to last visited
# on workspace if possible. If not, then changes only
# workspace. Used in WSM and Keybindings as main
# mechanism for workspace navigation.
# If infostore.desklastpage is 0, simply calls GotoDesk
DestroyFunc f_GotoDeskAndPage
AddToFunc f_GotoDeskAndPage
+ I Test (EnvMatch infostore.desklastpage 1, EnvMatch infostore.lpactive_$1 1) GotoDeskAndPage $0$1 $[infostore.last_page_dsk_$1]
+ I Test (EnvMatch infostore.desklastpage 1, !EnvMatch infostore.lpactive_$1 1) GotoDeskAndPage $0$1 0 0
+ I Test (!EnvMatch infostore.desklastpage 1) GotoDesk $[*]

# Function: f_MoveToDeskAndPage
# Moves window to specific desk and page in one call
# similar to GoToDeskAndPage builtin.
DestroyFunc f_MoveToDeskAndPage
AddToFunc f_MoveToDeskAndPage
+ I MoveToDesk $0 $1
+ I MoveToPage $2 $3

# Function: f_GotoDesk
# Wrapper for default NsCDE keybinding Meta+Tab and Meta+Ctrl+LRLR
# Calls GotoDesk and optionally changes page to last active one on desk
# if infostore.desklastpage is 1
# Parameters: none
DestroyFunc f_GotoDesk
AddToFunc f_GotoDesk
+ I GotoDesk $0 $1 $2 $3
+ I Test (EnvMatch infostore.desklastpage 1, EnvMatch infostore.lpactive_$[desk.n] 1) GotoPage $[infostore.last_page_dsk_$[desk.n]]

# Called from Front Panel and Mouse bindings
DestroyFunc f_MoveRaiseLower
AddToFunc f_MoveRaiseLower
+ M Move
+ C RaiseLower
+ D Raise
+ D Move
+ H Raise
+ H Move

# Called from Mouse bindings
# RaiswLower + custom action as $0
DestroyFunc f_RaiseLowerX
AddToFunc f_RaiseLowerX
+ M $0
+ D RaiseLower
+ H Nop

# Called from Mouse bindings and with 3rd TitleBar button
DestroyFunc f_ButtonMaximize
AddToFunc f_ButtonMaximize
+ M ResizeMoveMaximize 75 75 50-50w 50-50w ewmhiwa
+ H Maximize fullscreen
+ C Maximize
+ C $0
+ C $1
+ D Maximize ewmhiwa
+ D $0
+ D $1

# Called from key bindings, and window menu
DestroyFunc f_RegenerateWindow
AddToFunc f_RegenerateWindow
+ I InfoStoreAdd winres $[w.resource]
+ I Test (EnvMatch infostore.winres FrontPanel) f_FullyClearFrontPanelPressed
+ I RefreshWindow

# Used for toggling some Window Style on or off.
DestroyFunc f_ToggleWindowStyle
AddToFunc f_ToggleWindowStyle
+ I ThisWindow (State 1) WindowStyle $[0-]
+ I TestRc (Match) State 1 False
+ I TestRc (Match) Break 1
+ I WindowStyle !$[0-]
+ I State 1 True

# Used to center window and warp pointer to exact coordinates, usually 50 50
DestroyFunc f_AnimatedCenterWarp
AddToFunc f_AnimatedCenterWarp
+ I Next ($0, CirculateHit) AnimatedMove screen c 50-50w 50-50w ewmhiwa Warp
+ I Next ($0, CirculateHit) WarpToWindow $1 $2

DestroyFunc f_CenterWindow
AddToFunc f_CenterWindow
+ I ThisWindow Move screen c 50-50w 50-50w ewmhiwa

DestroyFunc f_OverScreen
AddToFunc f_OverScreen
+ I All ($0,CurrentPage,!Iconic) PipeRead 'ksh -c "(( $(($[w.width] + $[w.x])) > $[vp.width] )) || \
                                           (( $(($[w.height] + $[w.y])) > $[vp.height] )) || \
                                           (( $[w.x] < 0 )) || (( $[w.y] < 0 )) && echo State 7"'
+ I All ($0,CurrentPage,State 7) $[1-]
+ I All ($0,CurrentPage,State 7) State 7 false

DestroyFunc f_DeiconifyOnPage
AddToFunc f_DeiconifyOnPage
+ I Iconify False
+ I MoveToPage $0 $1

DestroyFunc f_MoveToPage
AddToFunc f_MoveToPage
+ I f_SetWSMConf
+ I PipeRead '$NSCDE_ROOT/bin/mkpagemenu $[infostore.pagematrixX] $[infostore.pagematrixY] menu_noicons MoveToPage "$[gt.Move To Page]:"'

DestroyFunc f_GoToPage
AddToFunc f_GoToPage
+ I f_SetWSMConf
+ I PipeRead '$NSCDE_ROOT/bin/mkpagemenu $[infostore.pagematrixX] $[infostore.pagematrixY] menu_icons GoToPage'

DestroyFunc f_MoveToWorkspace
AddToFunc f_MoveToWorkspace
+ I f_SetWSMConf
+ I PipeRead 'wsp=0; while [ ${wsp} -lt $[infostore.desknum] ]; do wsp=$((wsp + 1)); \
              wspname=$(egrep "^WSP:${wsp}:" $[infostore.wsmconf] | cut -d: -f3); \
              if [ "x${wspname}" = "x" ]; then wspname="$wsp"; fi; \
              echo "+ \\\"&${wsp} $[gt.Move To Workspace]:		${wspname}\\\" MoveToDesk 0 $(($wsp - 1))"; done'

# For multiscreen in FVWM 2.6.X: better show window on standard position when moved
# Best effort for Gkrellm and stalonetray too. Position are hardcoded for now ...
DestroyFunc f_MoveAllToThisScreen
AddToFunc f_MoveAllToThisScreen
+ I All MoveToScreen
+ I Test (EnvMatch infostore.pageshowrootpager 1) f_ShowLocalPager Move $[infostore.rootpagerposition] ewmhiwa
+ I All (Gkrellm, CirculateHit) Move screen c -0 +0
+ I All (stalonetray, CirculateHit) Move screen c -0 -0 ewmhiwa

DestroyFunc f_SaveGeometry
AddToFunc f_SaveGeometry
+ I PipeRead 'echo InfoStoreAdd window.pos.x $(($[w.x] - $[infostore.lscrn.$[w.screen].pos.x]))'
+ I PipeRead 'echo InfoStoreAdd window.pos.y $(($[w.y] - $[infostore.lscrn.$[w.screen].pos.y]))'
+ I ThisWindow Exec exec $[NSCDE_ROOT]/bin/confset.py \
  -t ini -c $[FVWM_USERDIR]/GeoDB.ini \
  -s $[infostore.lscrn.$[pointer.screen].width]x$[infostore.lscrn.$[pointer.screen].height] \
  -k $[w.resource],$[w.class] -v "$[cw.width]p $[cw.height]p $[infostore.window.pos.x]p $[infostore.window.pos.y]p"
+ I InfoStoreRemove window.pos.x
+ I InfoStoreRemove window.pos.y

DestroyFunc f_GetWinGeometry
AddToFunc f_GetWinGeometry
+ I PipeRead "echo $0 $1 $($[NSCDE_ROOT]/bin/confget.py \
  -c $[FVWM_USERDIR]/GeoDB.ini \
  -s $[infostore.lscrn.$[pointer.screen].width]x$[infostore.lscrn.$[pointer.screen].height] \
  -k $[w.resource],$[w.class] $[2-])"
+ I Test (EnvMatch infostore.lscrn.sls 1) MoveToScreen c

DestroyFunc f_RepositionWindow
AddToFunc f_RepositionWindow
+ I Current (!FixedSize,!FixedPosition) PipeRead "echo ResizeMove $($[NSCDE_ROOT]/bin/confget.py \
  -c $[FVWM_USERDIR]/GeoDB.ini -s $[infostore.lscrn.$[pointer.screen].width]x$[infostore.lscrn.$[pointer.screen].height] \
  -k $[w.resource],$[w.class])"
+ I Current (FixedSize) PipeRead "echo Move screen c $($[NSCDE_ROOT]/bin/confget.py \
  -c $[FVWM_USERDIR]/GeoDB.ini -s $[infostore.lscrn.$[pointer.screen].width]x$[infostore.lscrn.$[pointer.screen].height] \
  -k $[w.resource],$[w.class] | cut -d' ' -f 3,4)"
+ I Current (FixedPosition) PipeRead "echo Resize $($[NSCDE_ROOT]/bin/confget.py \
  -c $[FVWM_USERDIR]/GeoDB.ini -s $[infostore.lscrn.$[pointer.screen].width]x$[infostore.lscrn.$[pointer.screen].height] \
  -k $[w.resource],$[w.class] | cut -d' ' -f 1,2)"
+ I Test (EnvMatch infostore.lscrn.sls 1) MoveToScreen c

# Keep part of the keybindings which is common to menus in
# sync with menu declarations of them.
DestroyFunc f_KeyMenu
AddToFunc f_KeyMenu
+ I Piperead "$[NSCDE_ROOT]/libexec/keymenu -a"

# Execute what is in $1 - $X only a second time when
# function is called. Used to make double key bindings
# that will prevent accidental call while typing fast.
DestroyFunc f_DoubleBindKey
AddToFunc f_DoubleBindKey
+ I Test (EnvMatch infostore.dbk_$0 1) $[1-]
+ I Test (!EnvMatch infostore.dbk_$0 1) InfoStoreAdd dbk_$0 1
+ I Schedule $[infostore.menudclicktm] InfoStoreRemove dbk_$0

# Middle mouse on titlebar
DestroyFunc f_ScreenShot
AddToFunc f_ScreenShot
+ I Test (x import) Current Exec exec import $0 -window $[w.id] "$[HOME]/ScreenShot_$[w.class].$[w.id].$(date +%Y%m%d.%H%M%S).png"
+ I TestRc (NoMatch) Test (x xwd) Current Exec exec xwd $0 -out "$[HOME]/ScreenShot_$[w.class].$[w.id].$(date +%Y%m%d.%H%M%S).xwd"
+ I TestRc (NoMatch) None ("NsCDE-Notifier.f_ScreenShot") f_Notifier \
 "Screenshot Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_ScreenShot: No import(1) or xwd(1) for making a screenshot found in PATH] $[PATH]." "f_ScreenShot"

# Middle mouse on titlebar
DestroyFunc f_XwinInfo
AddToFunc f_XwinInfo
+ I Test (x xwininfo) Current Exec exec $[infostore.terminal] -e \
    "ksh -c 'echo -ne \"\033]0;X Window Info\007\"; xwininfo -all -id $[w.id] | less'"
+ I TestRc (NoMatch) None ("NsCDE-Notifier.f_XwinInfo") f_Notifier \
 "XwinInfo Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_XwinInfo: No xwininfo(1) tool found in PATH] $[PATH]." "f_XwinInfo"

# Middle mouse on titlebar
DestroyFunc f_Xprop
AddToFunc f_Xprop
+ I Test (x xprop) Current Exec exec $[infostore.terminal] -e \
    "ksh -c 'echo -ne \"\033]0;X Window Properties\007\"; xprop -id $[w.id] | less'"
+ I TestRc (NoMatch) None ("NsCDE-Notifier.f_Xprop") f_Notifier \
 "X Prop Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_Xprop: No xprop(1) tool found in PATH] $[PATH]." "f_Xprop"

# Root Window Screenshot
DestroyFunc f_RootScreenShot
AddToFunc f_RootScreenShot
+ I Test (x import) Schedule $0 Exec exec import -window root "$[HOME]/RootWinShot.$(date +%Y%m%d.%H%M%S).png"
+ I TestRc (NoMatch) Test (x xwd) Schedule $0 Exec exec xwd -root -out "$[HOME]/RootWinShot.$(date +%Y%m%d.%H%M%S).xwd"
+ I TestRc (NoMatch) None ("NsCDE-Notifier.f_RootScreenShot") f_Notifier \
 "Root Screenshot Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_RootScreenShot: No import(1) or xwd(1) for making a root window screenshot found in PATH] $[PATH]." \
 "f_RootScreenShot"

# Slight modification of the builting WindowListFunc
# Last two lines are signalization for Break in f_WinLists
DestroyFunc f_WindowList
AddToFunc f_WindowList
+ I Iconify False
+ I FlipFocus
+ I Raise
+ I WarpToWindow 50-50w 50-50w
+ I Test (EnvMatch infostore.wlisttype G) InfoStoreAdd wlistsig G
+ I Test (EnvMatch infostore.wlisttype L) InfoStoreAdd wlistsig L
+ I Test (EnvMatch infostore.desklastpage 1) InfoStoreAdd last_page_dsk_$[desk.n] "$[page.nx] $[page.ny]"

# Local and Global Window List toggle call
# Called with Alt+Escape keybinding.
# 1. It Schedules turn back on the start state on 1.25 seconds.
# 2. Puts WindowList type to (L)ocal if it is not set (initial)
# 3a. If WindowList type is (L)ocal, popup local WindowList with refefined function
# 3b. Put (G)lobal as WindowList type
# 3c. Breaks from function if WindowList signature is (L)ocal
# 4. If WindowList type is (G)lobal, popup global WindowList
DestroyFunc f_WinLists
AddToFunc f_WinLists
+ I Schedule 1250 InfoStoreAdd wlisttype L
+ I Schedule 1250 InfoStoreAdd wlistsig G
+ I Test (!EnvMatch infostore.wlisttype L) \
    Test (!EnvMatch infostore.wlisttype G) InfoStoreAdd wlisttype L
+ I Test (EnvMatch infostore.wlisttype L) \
    WindowList Root c c NoGeometry TitleForAllDesks NoCurrentDeskTitle \
    NoNumInDeskTitle CurrentDesk Function f_WindowList
+ I Test (EnvMatch infostore.wlisttype L) InfoStoreAdd wlisttype G
+ I Test (EnvMatch infostore.wlistsig L) Break
+ I Test (EnvMatch infostore.wlisttype G) WindowList Root c c NoGeometry \
    TitleForAllDesks NoCurrentDeskTitle NoNumInDeskTitle Function f_WindowList

# Function: f_MouseWinList
# Adds ability to remember last page when positoned from
# WindowList called from mouse click. Doesn't take any parameters.
DestroyFunc f_MouseWinList
AddToFunc f_MouseWinList
+ I Iconify False
+ I FlipFocus
+ I Raise
+ I WarpToWindow 10p 10p
+ I Test (EnvMatch infostore.desklastpage 1) InfoStoreAdd last_page_dsk_$[desk.n] "$[page.nx] $[page.ny]"

# Function: f_SafeFvwmCmd
# Purpose: run fvwm command only if it has some arguments
# used in f_SysAddWindowEvent while calling f_GetWinGeometry
# Parameters: $0 - Fvwm command, $[1-], arguments
DestroyFunc f_SafeFvwmCmd
AddToFunc f_SafeFvwmCmd
+ I InfoStoreAdd fvwmcmdargs "A$[1-]Z"
+ I Test (!EnvMatch infostore.fvwmcmdargs AZ) $0 $[1-]
+ I InfoStoreRemove infostore.fvwmcmdargs

#######################
# Front Panel functions
#######################
DestroyFunc f_RestartFrontPanel
AddToFunc f_RestartFrontPanel
+ I KillModule FvwmButtons FrontPanel
+ I PipeRead "$[NSCDE_ROOT]/libexec/fpseticon pre"
+ I f_Readcfg FrontPanel
+ I ModuleSynchronous Timeout 5 FvwmButtons FrontPanel
+ I f_SendToPGM
+ I Schedule 30 f_FrontPanelSetCustom
+ I Schedule 300 f_FrontPanelSetCustom

DestroyFunc f_RestoreFrontPanel
AddToFunc f_RestoreFrontPanel
+ I None (FvwmButtons,FrontPanel,CirculateHit) InfoStoreAdd _initfp 1
+ I Test (EnvMatch infostore._initfp 1) f_ReadCfg FrontPanel
+ I Test (EnvMatch infostore._initfp 1) ModuleSynchronous Timeout 5 FvwmButtons FrontPanel
+ I Test (EnvMatch infostore._initfp 1) Schedule 30 f_FrontPanelSetCustom
+ I Test (EnvMatch infostore._initfp 1) Schedule 300 f_FrontPanelSetCustom
+ I Test (EnvMatch infostore._initfp 1) InfoStoreRemove _initfp
+ I All (FvwmButtons,FrontPanel,CirculateHit,Iconic) Iconify False
+ I All (FvwmButtons,FrontPanel,CirculateHit,!Sticky) Stick
+ I All (FvwmButtons,FrontPanel,CirculateHit) $0 $1
+ I All (FvwmButtons,FrontPanel,CirculateHit) RaiseLower
+ I All (FvwmButtons,FrontPanel,CirculateHit) Resize 1015p 79p
+ I All (FvwmButtons,FrontPanel,CirculateHit) AnimatedMove screen c 50-50w -0p ewmhiwa
+ I Test (EnvMatch infostore.fp_needs_ptr 1) All (FvwmButtons,FrontPanel,CirculateHit,!HasPointer,!Shaded) WarpToWindow 50 50
+ I Test (EnvMatch infostore.fp_needs_ptr 1) InfoStoreAdd fp_needs_ptr 0
+ I All (FvwmButtons,FrontPanel,CirculateHit,!HasPointer) InfoStoreAdd fp_needs_ptr 1

DestroyFunc f_KeyFromFpToSubanel
AddToFunc f_KeyFromFpToSubanel
+ I Test (!EnvMatch infostore.$0-Enabled 1) Break
+ I None ($0) SendToModule FrontPanel PressButton $0
+ I None ($0) Wait $0
+ I Schedule 250 All ($0) WarpToWindow 50 50
+ I Schedule 2000 Break

DestroyFunc f_KeyFromSubpanelToFP
AddToFunc f_KeyFromSubpanelToFP
+ I Test (!EnvMatch infostore.$0-Enabled 1) Break
+ I All ($0) SendToModule FrontPanel PressButton $0
+ I All (FrontPanel, CirculateHit, !HasPointer) WarpToWindow 50 50

# We must call fvwm-menu-desktop here to regenerate local icon cache just in case
DestroyFunc f_RefreshSubpanel
AddToFunc f_RefreshSubpanel
+ I Exec exec fvwm-menu-desktop --mini-icons-dir $[FVWM_USERDIR]/icons --enable-mini-icons -s 32 --theme NsCDE --include-items none > /dev/null 2>&1
+ I PipeRead "$[NSCDE_ROOT]/libexec/generate_subpanels > $[FVWM_USERDIR]/NsCDE-Subpanels.conf 2> /dev/null"
+ I f_ReadCfg Subpanels
+ I KillModule FvwmButtons $0
+ I SendToModule FrontPanel PressButton $0
+ I Schedule 800 SendToModule FrontPanel PressButton $0
+ I Schedule 3200 Exec exec $[NSCDE_ROOT]/bin/xdowrapper

DestroyFunc f_FrontPanelAction
AddToFunc f_FrontPanelAction
+ I Piperead "$[NSCDE_ROOT]/libexec/fpexec $0 $1"
+ I InfoStoreAdd fpcurrent $0
+ I Test (EnvMatch infostore.fplastpressed Btn*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 21
+ I Test (EnvMatch infostore.fplastpressed FpLite, !EnvMatch infostore.fpcurrent FpLite) SendToModule FpLite SendString 1 2 unselect
+ I Test (EnvMatch infostore.fplastpressed FpWSM) SendToModule WSM SendString 30 2 unselect
+ I Test (EnvMatch infostore.fplastpressed FpPGM) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 21
+ I Test (EnvMatch infostore.fplastpressed FpLock) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 21
+ I Test (EnvMatch infostore.fplastpressed FpExit) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 21
+ I Test (EnvMatch infostore.fplastpressed NsCDE-Subpanel*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 1
+ I Schedule 100 SendToModule FrontPanel ChangeButton $0 Colorset $2
+ I InfoStoreAdd fplastpressed $0

DestroyFunc f_FrontPanelMenuAction
AddToFunc f_FrontPanelMenuAction
+ I Piperead "$[NSCDE_ROOT]/libexec/fpexec $0 $1"

DestroyFunc f_FrontPanelPropsMenu
AddToFunc f_FrontPanelPropsMenu
+ I DestroyMenu m_FrontPanelPropsMenu
+ I AddToMenu m_FrontPanelPropsMenu " $[1-] " Title
+ I AddToMenu m_FrontPanelPropsMenu "$[1-]" SendToModule FrontPanel PressButton Btn$0
+ I AddToMenu m_FrontPanelPropsMenu "" Nop
+ I AddToMenu m_FrontPanelPropsMenu "$[gt.Reset This Button]" Exec exec $[NSCDE_ROOT]/libexec/fp_manage_subpanel -p $0 -r $[infostore.FP.Btn$0.type]
+ I AddToMenu m_FrontPanelPropsMenu "" Nop
+ I Test (EnvMatch infostore.NsCDE-Subpanel$0-Enabled 1) \
    AddToMenu m_FrontPanelPropsMenu "$[gt.Reset Subpanel]" \
    f_RunQuickScriptDialog ActionForm \
    "$[gt.Do you want to reset Subpanel] $0 $[gt.to default configuration?]" \
    $[gt.Yes] $[gt.No] "$[gt.Subpanel Reset Confirmation]" "f_ResetSubpanel $0" Nop
+ I Test (EnvMatch infostore.NsCDE-Subpanel$0-Enabled 0) \
    AddToMenu m_FrontPanelPropsMenu "$[gt.Add Subpanel]" \
    f_FrontPanelManageSubpanels $0 -a
+ I Test (EnvMatch infostore.NsCDE-Subpanel$0-Enabled 1) \
    AddToMenu m_FrontPanelPropsMenu "$[gt.Delete Subpanel]" \
    f_FrontPanelManageSubpanels $0 -d
+ I AddToMenu m_FrontPanelPropsMenu "" Nop
+ I AddToMenu m_FrontPanelPropsMenu "$[gt.Help]" f_DisplayURL "Front Panel Help" $[NSCDE_ROOT]/share/doc/html/NsCDE-applets-docks-panels.html
+ I ChangeMenuStyle CommonAppMenu m_FrontPanelPropsMenu
+ I Popup m_FrontPanelPropsMenu mouse -0m -0m

DestroyFunc f_FrontPanelManageSubpanels
AddToFunc f_FrontPanelManageSubpanels
+ I Exec exec $[NSCDE_ROOT]/libexec/fp_manage_subpanel -p $0 $1
+ I Exec exec $[NSCDE_ROOT]/libexec/generate_subpanels > $[FVWM_USERDIR]/NsCDE-Subpanels.conf
+ I Schedule 800 f_ReadCfg Subpanels
+ I Schedule 1200 f_RestartFrontPanel

DestroyFunc f_SubpanelPropsMenu
AddToFunc f_SubpanelPropsMenu
+ I DestroyMenu m_SubpanelPropsMenu
+ I AddToMenu m_SubpanelPropsMenu " $2 " Title
+ I AddToMenu m_SubpanelPropsMenu "$2" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -e
+ I AddToMenu m_SubpanelPropsMenu "" Nop
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Move Up]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -a up
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Move Down]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -a down
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Move to Beginning]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -a begin
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Move to End]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -a end
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Copy to Main Panel]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -c $[infostore.FP.Btn$0.type]
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Delete]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -d
+ I AddToMenu m_SubpanelPropsMenu "" Nop
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Help]" f_DisplayURL "Subpanels Help" $[NSCDE_ROOT]/share/doc/html/NsCDE-Subpanels.html
+ I ChangeMenuStyle CommonAppMenu m_SubpanelPropsMenu
+ I Popup m_SubpanelPropsMenu mouse -0m -0m

DestroyFunc f_DeleteFromSubpanel
AddToFunc f_DeleteFromSubpanel
+ I Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -a delete

DestroyFunc f_SubpanelItemExec
AddToFunc f_SubpanelItemExec
+ I SendToModule $0 ChangeButton $[infostore.subpanel_$0_last_sel_id] Colorset 49
+ I SendToModule $0 ChangeButton $1 Colorset 16
+ I InfoStoreAdd subpanel_$0_last_sel_id $1
+ I $[2-]

DestroyFunc f_ResetSubpanel
AddToFunc f_ResetSubpanel
+ I Test (R $[FVWM_USERDIR]/Subpanels.actions) \
    Exec exec $[NSCDE_ROOT]/bin/ised -c '/^S$0,\(NAME\|WIDTH\|ENABLED\|ENTRY\),.*/d' -f $[FVWM_USERDIR]/Subpanels.actions
+ I Schedule 400 f_RefreshSubpanel NsCDE-Subpanel$0

# $1 can be "pre" argument for storing InfoStore variables prior to setting icons.
DestroyFunc f_FrontPanelSetCustom
AddToFunc f_FrontPanelSetCustom
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn1"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn2"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn3"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn4"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn5"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn6"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn7"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn8"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn9"
+ I Piperead "$[NSCDE_ROOT]/libexec/fpseticon Btn10"
+ I Test (EnvMatch infostore.wsmcolored 1) SendToModule FrontPanel ChangeButton FpWSM Colorset 22

# Called from f_FocusChange FvwmEvent MainLoop - this
# clears selected state for Front Panel and Style Manager
# buttons when their windows are not in focus.
# Break 1 is here to allow continuation in second level
# function f_FullyClearFrontPanelPressed
DestroyFunc f_ClearFrontPanelPressed
AddToFunc f_ClearFrontPanelPressed
+ I Test (EnvMatch infostore.fplastpressed Btn*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 21
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed NsCDE-Subpanel*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 1
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpExit) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 21
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpWSM) SendToModule WSM SendString 30 2 unselect
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpLite) SendToModule FpLite SendString 1 2 unselect
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpPGM) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 21
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpLock) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 21

# Middle click on handle of the Front Panel clears selected state
# for all buttons.
DestroyFunc f_FullyClearFrontPanelPressed
AddToFunc f_FullyClearFrontPanelPressed
+ I f_ClearFrontPanelPressed
+ I InfoStoreRemove fplastpressed

# Called from f_FocusChange FvwmEvent MainLoop - this
# sets back selected state for Front Panel and Style Manager
# buttons when their windows are focused.
DestroyFunc f_PutFrontPanelPressed
AddToFunc f_PutFrontPanelPressed
+ I Test (EnvMatch infostore.fplastpressed Btn*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 29
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed NsCDE-Subpanel*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 17
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpExit) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 30
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpWSM) SendToModule WSM SendString 30 2 unclick
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpLite) SendToModule FpLite SendString 1 2 unclick
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpPGM) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 30
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpLock) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 30

# Function: f_FrontPanelVisualFocus
# This function serves FrontPanel to make it appear as
# MouseFocus instead of ClickToFocus.
# Called by: f_LeaveWindow
# $0 = BorderColorset
# $1 = FrontPanel function (f_ClearFrontPanelPressed or f_PutFrontPanelPressed)
# $2 = InfoStoreAdd fp_event_leave - either 0 or 1
DestroyFunc f_FrontPanelVisualFocus
AddToFunc f_FrontPanelVisualFocus
+ I CursorStyle WAIT left_ptr
+ I f_ToggleWindowStyle BorderColorset $0
+ I $1
+ I Schedule 250 CursorStyle WAIT cursors/WaitCursor.xpm
+ I InfoStoreAdd fp_event_leave $2

# Function: f_CloseFrontPanel
# Used in: f_WindowOpsFP menu generator function
DestroyFunc f_CloseFrontPanel
AddToFunc f_CloseFrontPanel
+ I KillModule FvwmButtons FrontPanel
+ I Deschedule $0
+ I Schedule 100 Deschedule $0
+ I Schedule 200 Deschedule $0

#################################################
# Helper Functions used by FvwmAuto and FvwmEvent
#################################################
# Function f_AutoShadeAction
# Helper function of f_AutoShade
DestroyFunc f_AutoShadeAction
AddToFunc f_AutoShadeAction
+ I Schedule $0 $[w.id]ff01 WindowId $[w.id] WindowShade $1 $2
+ I Schedule $0 $[w.id]ff01 Deschedule $[w.id]ff01

# Function: f_AutoShade
# FvwmAuto function which automatically shades window
DestroyFunc f_AutoShade
AddToFunc f_AutoShade
+ I ThisWindow ($0) Deschedule $[w.id]ff01
+ I ThisWindow ($0) KeepRc ThisWindow (Shaded) WindowShade off
+ I TestRc (NoMatch) All ($0, !Shaded) f_AutoShadeAction $1 $2 $3

# Function f_AutoIconifyAction
# Helper function of f_AutoIconify
DestroyFunc f_AutoIconifyAction
AddToFunc f_AutoIconifyAction
+ I Schedule $0 $[w.id]ff02 Iconify on $1
+ I Schedule $0 $[w.id]ff02 Deschedule $[w.id]ff02

# Function: f_AutoIconify
# FvwmAuto function which automatically (de)iconifies window
DestroyFunc f_AutoIconify
AddToFunc f_AutoIconify
+ I ThisWindow ($0) Deschedule $[w.id]ff02
+ I ThisWindow ($0) KeepRc ThisWindow (Iconified) Iconify toggle
+ I TestRc (!Match) All ($0, !Iconified, !HasPointer) f_AutoIconifyAction $1

# Function f_AutoDeleteAction
# Helper function of f_AutoDelete
DestroyFunc f_AutoDeleteAction
AddToFunc f_AutoDeleteAction
+ I Schedule $0 $[w.id]ff03 Delete $1
+ I Schedule $0 $[w.id]ff03 Deschedule $[w.id]ff03

# Function: f_AutoDelete
# FvwmAuto function which automatically deletes window
DestroyFunc f_AutoDelete
AddToFunc f_AutoDelete
+ I ThisWindow ($0) Deschedule $[w.id]ff03
+ I ThisWindow ($0) KeepRc ThisWindow (HasPointer) Nop
+ I TestRc (Match) All ($0, !HasPointer) f_AutoDeleteAction $1

# Function f_AutoRaiseAction
# Helper function of f_AutoRaise
DestroyFunc f_AutoRaiseAction
AddToFunc f_AutoRaiseAction
+ I Schedule $0 $[w.id]ff04 Raise $1
+ I Schedule $0 $[w.id]ff04 Deschedule $[w.id]ff04

# Function: f_AutoRaise
# FvwmAuto function which automatically raises window
DestroyFunc f_AutoRaise
AddToFunc f_AutoRaise
+ I ThisWindow ($0) Deschedule $[w.id]ff04
+ I ThisWindow ($0) KeepRc Schedule $1 $[w.id] ThisWindow (HasPointer) Raise
+ I TestRc (!Match) All ($0, HasPointer) f_AutoRaiseAction $1

# Function f_AutoLowerAction
# Helper function of f_AutoLower
DestroyFunc f_AutoLowerAction
AddToFunc f_AutoLowerAction
+ I Schedule $0 $[w.id]ff05 Lower $1
+ I Schedule $0 $[w.id]ff05 Deschedule $[w.id]ff05

# Function: f_AutoLower
# FvwmAuto function which automatically lowers window
DestroyFunc f_AutoLower
AddToFunc f_AutoLower
+ I ThisWindow ($0) Deschedule $[w.id]ff05
+ I ThisWindow ($0) KeepRc ThisWindow (!HasPointer) Lower
+ I TestRc (!Match) All ($0, Raised, !HasPointer) f_AutoLowerAction $1

# Function f_AutoRefreshWindowAction
# Helper function of f_AutoRefreshWindow
DestroyFunc f_AutoRefreshWindowAction
AddToFunc f_AutoRefreshWindowAction
+ I Schedule $0 $[w.id]ff06 Raise $1
+ I Schedule $0 $[w.id]ff06 Deschedule $[w.id]ff06

# Function: f_AutoRefreshWindow
# FvwmAuto function which automatically refreshes window
DestroyFunc f_AutoRefreshWindow
AddToFunc f_AutoRefreshWindow
+ I ThisWindow ($0) Deschedule $[w.id]ff06
+ I ThisWindow ($0) KeepRc Schedule $1 $[w.id] ThisWindow (HasPointer) RefreshWindow
+ I TestRc (!Match) All ($0, HasPointer) f_AutoRefreshWindowAction $1


#####################
# Misc core functions
#####################

# Called from NsCDE-Main.conf during startup
# This is "init script" for Local Pager
DestroyFunc f_StartLocalPager
AddToFunc f_StartLocalPager
+ I All ("LocalPager") Break 1
+ I Module FvwmPager LocalPager * $[infostore.fvwmdesknum]
+ I Wait LocalPager
+ I All ("LocalPager") State 6
+ I All ("LocalPager", State 6) Schedule 1000 Move +32768p +32768p

# Local Pager positioning (if configured)
# $[0-] is usually Move xxx yyy or AnimatedMove xxx yyy
# Depends on: f_HideLocalPager
DestroyFunc f_ShowLocalPager
AddToFunc f_ShowLocalPager
+ I All ("LocalPager", !State 6) f_Reschedule Periodic 1250 131313 All ("LocalPager", !HasPointer, !State 6) f_HideLocalPager
+ I PointerWindow ("FrontPanel", CirculateHit) All ("LocalPager", !State 6) $[0-]
+ I All ("LocalPager", !State 6) Break 1
+ I All (CurrentPage, GlobalPager) Break 1
+ I Deschedule 131313
+ I All ("LocalPager", State 6) State 6 False
+ I All ("LocalPager") Raise
+ I PointerWindow (!"LocalPager") All ("LocalPager", !State 6) $[0-]
+ I TestRc (Error) All ("LocalPager", !State 6) $[0-]
+ I Schedule Periodic 1250 131313 All ("LocalPager", !HasPointer, !State 6) f_HideLocalPager

# Local Pager hiding (if configured)
# Depends on: f_DescheduleAfterAction
DestroyFunc f_HideLocalPager
AddToFunc f_HideLocalPager
+ I f_DescheduleAfterAction 131313 Move +32768p +32768p
+ I All ("LocalPager") State 6 toggle

DestroyFunc f_KeyShowLocalPager
AddToFunc f_KeyShowLocalPager
+ I InfoStoreRemove dbk_localpager
+ I f_ShowLocalPager $[0-]
+ I All ("LocalPager", CirculateHit, !Transient) f_OverScreen LocalPager PlaceAgain
+ I All ("LocalPager", CirculateHit, !Transient) WarpToWindow 50 50

# Setup Global Pager Function
# $0 is for -transient argument
DestroyFunc f_ShowGlobalPager
AddToFunc f_ShowGlobalPager
+ I Test (EnvMatch infostore.dbk_globalpager 1) InfoStoreRemove dbk_globalpager
+ I All (GlobalPager, State 5) KillModule FvwmPager GlobalPager
+ I All (GlobalPager, !State 5) f_NonTransientPager
+ I All (GlobalPager) Break 1
+ I All (CurrentPage, "LocalPager", !Iconic) Iconify True
+ I All ("WspLocPager") KillModule FvwmPager WspLocPager
+ I InfoStoreAdd gp_opts "$[0-]"
+ I Test (EnvMatch infostore.gp_opts -transient) \
    Module FvwmPager $[infostore.gp_opts] GlobalPager 0 $[infostore.fvwmdesknum]
+ I Test (!EnvMatch infostore.gp_opts -transient) \
    Module FvwmPager GlobalPager 0 $[infostore.fvwmdesknum]
+ I Wait GlobalPager
+ I All ("GlobalPager", CirculateHit, !Transient) $[infostore.gp_opts]
+ I All ("GlobalPager", CirculateHit, !Transient) f_OverScreen GlobalPager PlaceAgain
+ I All ("GlobalPager", CirculateHit, !Transient) WarpToWindow 50 50
+ I Schedule Periodic 1250 141414 \
    All ("GlobalPager", !State 5, !HasPointer, CirculateHit, !Transient) \
    f_DescheduleAfterAction 141414 KillModule FvwmPager GlobalPager

DestroyFunc f_NonTransientPager
AddToFunc f_NonTransientPager
+ I State 5 toggle
+ I State 1 toggle
+ I f_ToggleWindowStyle Title
+ I WindowStyle IconOverride, Icon NsCDE/GWM.l.xpm, MiniIcon NsCDE/GWM.t.xpm, WindowListHit, Button 4

# This uses catalogue of possible applications from $NSCDE_ROOT/share/fallback/app-catalog/
# It defines terminal, filemgr, xeditor and such if NsCDE.conf does not defines them.
DestroyFunc f_FindApp
AddToFunc f_FindApp
+ I Test (x $[infostore.$$0]) Break 1
+ I Test (!f $[NSCDE_ROOT]/share/fallback/app-catalog/$1) f_Notifier \
                  "$[gt.App Finder]" \
                  "$[gt.Dismiss]" \
                  "NsCDE/Error.xpm" \
                  "$[gt.Error: Application Catalog] $1 $[gt.for defining] \\\"$0\\\" $[gt.does not exist]."
+ I PipeRead "echo InfoStoreAdd $0 \"$($[NSCDE_ROOT]/libexec/appfinder $1)\""
+ I Test (!Init, !Restart, EnvMatch infostore.$$0 "NOAPP") f_Notifier \
                  "App Finder" \
                  "Dismiss" \
                  "NsCDE/Error.xpm" \
                  "$[gt.Error defining] \\\"$0\\\" $[gt.automatic default: cannot find any usable application.]"
+ I Test (!EnvMatch infostore.$$0 "NOTFOUND") Echo NsCDE: Selected default for $0: $[infostore.$$0]

DestroyFunc f_WideTerm
AddToFunc f_WideTerm
+ I Current (*term*,Maximized) Maximize toggle
+ I TestRc (NoMatch) Current (*term*) \
    PipeRead \
    "echo ResizeMoveMaximize $((($[infostore.lscrn.$[w.screen].width] / 100) * 75))p \
      $((($[infostore.lscrn.$[w.screen].height] / 100) * 75))p $((50 / $[infostore.lscrn.cnt]))-50w -100p ewmhiwa"
+ I TestRc (Match) MoveToScreen c
+ I TestRc (Match) Break
+ I Current (*Term*,Maximized) Maximize toggle
+ I TestRc (NoMatch) Current (*Term*) \
    PipeRead \
    "echo ResizeMoveMaximize $((($[infostore.lscrn.$[w.screen].width] / 100) * 75))p \
      $((($[infostore.lscrn.$[w.screen].height] / 100) * 75))p $((50 / $[infostore.lscrn.cnt]))-50w -100p ewmhiwa"
+ I TestRc (Match) MoveToScreen c
+ I TestRc (Match) Break
+ I Current (*xvt*,Maximized) Maximize toggle
+ I TestRc (NoMatch) Current (*xvt*) \
    PipeRead \
    "echo ResizeMoveMaximize $((($[infostore.lscrn.$[w.screen].width] / 100) * 75))p \
      $((($[infostore.lscrn.$[w.screen].height] / 100) * 75))p $((50 / $[infostore.lscrn.cnt]))-50w -100p ewmhiwa"
+ I TestRc (Match) MoveToScreen c

# If the window exists, points the pointer to it. If it does not exists,
# Checks for program existance, removes arg1 and arg2 and execes the rest.
# Parameters: $0 - Window Name or Class Name, $1, binary to check for in PATH
# $2/$* - the rest of the command line.
DestroyFunc f_WarpOrExec
AddToFunc f_WarpOrExec
+ I Next ($0, CirculateHit) WarpToWindow 50 50
+ I TestRc (NoMatch) None ($0) Test (x $1) Exec exec $[2-]

# Exec program if it is not present, move to page/desk if present
# elseware, close if $1 is Close and present + visible on the current page.
DestroyFunc f_ToggleExecWindow
AddToFunc f_ToggleExecWindow
+ I None ($0,CirculateHit) Exec exec $[2-]
+ I Next ($0,CirculateHit,CurrentPage,Visible) $1
+ I Next ($0,CirculateHit) MoveToDesk
+ I Next ($0,CirculateHit) MoveToPage
+ I Next ($0,CirculateHit) Raise

# Spawn FVWM module if it is not present, move to page/desk if present
# elseware, kill module if present and visible on the current page.
# Function name referenced in SubpanelMgr
DestroyFunc f_ToggleFvwmModule
AddToFunc f_ToggleFvwmModule
+ I None ($1,CirculateHit) Module $[0-]
+ I Next ($1,CirculateHit,CurrentPage,Visible) KillModule $0 $1
+ I Next ($1,CirculateHit) MoveToDesk
+ I Next ($1,CirculateHit) MoveToPage
+ I Next ($1,CirculateHit) Raise

# Execute FVWM function if $0 is not present, warp to window if present
# elseware, do $1 with $0 if $0 is present + visible on the current page.
# Function name referenced in SubpanelMgr
DestroyFunc f_ToggleFvwmFunc
AddToFunc f_ToggleFvwmFunc
+ I None ($0,CirculateHit) $[2-]
+ I Next ($0,CirculateHit,CurrentPage,Visible) $1
+ I Next ($0,CirculateHit) WarpToWindow 50 50
+ I Next ($0,CirculateHit) Raise

# Function which moves mouse in some direction before calling a command
# or another function. Used to move mouse from edge of the screen before
# calling things which are positioning themselves near the pointer position.
DestroyFunc f_MoveCursorAndExec
AddToFunc f_MoveCursorAndExec
+ I CursorMove $0 $1
+ I $[2-]

# Xscreensaver management
DestroyFunc f_Xscreensaver
AddToFunc f_Xscreensaver
+ I Test (!x xscreensaver-command) None ("NsCDE-Notifier.f_Xscreensaver_1") f_Notifier \
    "Screensaver Error" "Dismiss" "NsCDE/Error.xpm" \
    "$[gt.Cannot find \\\"xscreensaver-command\\\" in PATH] $[PATH]." "f_Xscreensaver_1"
+ I TestRc (Match) Break
+ I Test (!EnvMatch infostore.nscde_use_xscreensaver 1) None ("NsCDE-Notifier.f_Xscreensaver_2") f_Notifier \
    "Screensaver Error" "Dismiss" "NsCDE/Error.xpm" \
    "Screensaver has been disabled in configuration. See \\\"nscde_use_xscreensaver\\\" in your NsCDE.conf." "f_Xscreensaver_2"
+ I TestRc (Match) Break
+ I InfoStoreAdd xsc_cmd $0
+ I PipeRead "echo InfoStoreAdd xsc_status A$(pgrep -u $[USER] xscreensaver)O"
+ I Test (EnvMatch infostore.xsc_status "AO", !EnvMatch infostore.xsc_cmd "-restart", !EnvMatch infostore.xsc_cmd "-start") f_Notifier \
    "Screensaver Error" "Dismiss" "NsCDE/Warning.xpm" \
    "$[gt.No X Screen Saver (xscreensaver) is running on display] $[DISPLAY]. $[gt.Attempting to start it and re-execute f_Xscreensaver] $0."
+ I Test (EnvMatch infostore.xsc_status "AO") Exec exec xscreensaver
+ I Test (EnvMatch infostore.xsc_status "AO") Schedule 1000 f_Xscreensaver $0
+ I Test (EnvMatch infostore.xsc_status "AO") Break 1
+ I Test (EnvMatch infostore.xsc_cmd -stop) Exec exec pkill -STOP -u $[USER] -xf xscreensaver
+ I Test (EnvMatch infostore.xsc_cmd -stop) SendToModule FrontPanel ChangeButton FpLock Icon NsCDE/FplockSuspended.s.pm
+ I Test (EnvMatch infostore.xsc_cmd -cont) Exec exec pkill -CONT -u $[USER] -xf xscreensaver
+ I Test (EnvMatch infostore.xsc_cmd -cont) SendToModule FrontPanel ChangeButton FpLock Icon NsCDE/FpLock.xpm
+ I Test (EnvMatch infostore.xsc_cmd -lock) Exec exec xscreensaver-command $0
+ I Test (EnvMatch infostore.xsc_cmd -prefs) Exec exec xscreensaver-command $0
+ I Test (EnvMatch infostore.xsc_cmd -restart) Exec exec pkill -u $[USER] xscreensaver
+ I Test (EnvMatch infostore.xsc_cmd -restart) Schedule 1000 Exec exec xscreensaver
+ I Test (EnvMatch infostore.xsc_cmd -start) Schedule 1000 Exec exec xscreensaver
+ I Test (EnvMatch infostore.xsc_cmd -kill) Exec exec pkill -u $[USER] -xf xscreensaver

# Standalone XSETTINGS daemon xsettingsd support
DestroyFunc f_Xsettingsd
AddToFunc f_Xsettingsd
+ I Test (!EnvMatch infostore.nscde_use_xsettingsd 1) Break 1
+ I Test (!x xsettingsd) Break 1
+ I Test (EnvMatch infostore.nscde_use_xsettingsd 1, !r $[FVWM_USERDIR]/Xsettingsd.conf) \
    Exec exec cp -f $[NSCDE_ROOT]/share/templates/Xsettingsd.conf $[FVWM_USERDIR]/Xsettingsd.conf
+ I Test (!r $[FVWM_USERDIR]/Xsettingsd.conf) Break 1
+ I InfoStoreAdd xsettingsd_action $0
+ I Test (EnvMatch infostore.xsettingsd_action start) Exec exec ksh -c 'pkill -u "$[USER]" xsettingsd; exec xsettingsd -c $[FVWM_USERDIR]/Xsettingsd.conf'
+ I Test (EnvMatch infostore.xsettingsd_action restart) Exec exec ksh -c 'pkill -u "$[USER]" xsettingsd; exec xsettingsd $[FVWM_USERDIR]/Xsettingsd.conf'
+ I Test (EnvMatch infostore.xsettingsd_action reload) Exec exec pkill -HUP -u "$[USER]" xsettingsd
+ I Test (EnvMatch infostore.xsettingsd_action stop) Exec exec pkill -u "$[USER]" xsettingsd
+ I Test (EnvMatch infostore.xsettingsd_action status) PipeRead "echo Echo $(pgrep -u $[USER] xsettingsd)"
+ I InfoStoreRemove xsettingsd_action

# Standalone Tray daemon stalonetray support
DestroyFunc f_Stalonetray
AddToFunc f_Stalonetray
+ I Test (!EnvMatch infostore.nscde_use_stalonetray) Break 1
+ I Test (!x stalonetray) Break 1
+ I Test (EnvMatch infostore.nscde_use_stalonetray 1, !r $[FVWM_USERDIR]/Stalonetray.conf) \
    Exec exec cp -f $[NSCDE_ROOT]/share/templates/Stalonetray.conf $[FVWM_USERDIR]/Stalonetray.conf
+ I Test (!r $[FVWM_USERDIR]/Stalonetray.conf) Break 1
+ I InfoStoreAdd stalonetray_action $0
+ I Test (EnvMatch infostore.stalonetray_action start) Exec exec ksh -c 'pkill -u "$[USER]" stalonetray; exec stalonetray -c $[FVWM_USERDIR]/Stalonetray.conf'
+ I Test (EnvMatch infostore.stalonetray_action restart) Exec exec ksh -c 'pkill -u "$[USER]" stalonetray; exec stalonetray -c $[FVWM_USERDIR]/Stalonetray.conf'
+ I Test (EnvMatch infostore.stalonetray_action stop) Exec exec pkill -u "$[USER]" stalonetray
+ I Test (EnvMatch infostore.stalonetray_action status) PipeRead "echo Echo $(pgrep -u $[USER] stalonetray)"
+ I InfoStoreRemove stalonetray_action

# For displaying documentation purposes, or sending URL to web browser
DestroyFunc f_DisplayURL
AddToFunc f_DisplayURL
+ I Echo Sending Link $1 from $0 to $[infostore.browser]
+ I Module FvwmScript WaitNotice "$0" "Sending Link to $[infostore.browser]" " ... " 1800
+ I Exec exec $[infostore.browser] $1

# FVWM Version check function - usually called on init
DestroyFunc f_FvwmVersionCheck
AddToFunc f_FvwmVersionCheck
+ I Test (Version >= 2.6.7) Break 1
+ I Test (Version < 2.6.7) f_Notifier \
 "NsCDE: FVWM Version Check" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.FVWM version] $[version.num] $[gt.is not supported by NsCDE] $[NSCDE_VERSION] \
 $[gt.(FVWM 2.6.7 is the oldest supported and tested version).] \
 $[gt.Functional problems, misbehaviour and unpredictable behaviour can be expected if this session is going to continue.] \
 $[gt.Please install and use newer FVWM version. Logout, or continue with a risk.]"

# Make a small time frame for action repeat to succeed.
# Used for Front Panel subpanels enablement currently
# $0 - name part of the infostore variable to set
# $1 - schedule time in milliseconds
# $2 - the rest of the command line
DestroyFunc f_DoubleClickExec
AddToFunc f_DoubleClickExec
+ I Test (EnvMatch infostore.$0 1) $2
+ I TestRc (Match) Break
+ I Test (!EnvMatch infostore.$0 1) InfoStoreAdd $0 1
+ I Schedule $1 InfoStoreRemove $0

# Deschedule action $0 after $[1-] is finally executed
# Initially created for f_ShowLocalPager
DestroyFunc f_DescheduleAfterAction
AddToFunc f_DescheduleAfterAction
+ I $[1-]
+ I Deschedule $0

# f_Reschedule
# Deschedule identified action and schedule it again
# Initially created for f_ShowLocalPager
DestroyFunc f_Reschedule
AddToFunc f_Reschedule
+ I InfoStoreAdd sched_type $0
+ I Test (EnvMatch infostore.sched_type Periodic) Deschedule $2
+ I Test (!EnvMatch infostore.sched_type Periodic) Deschedule $1
+ I Schedule $[0-]
+ I InfoStoreRemove sched_type

# First Run Setup Function
# Called from config/NsCDE-Init.conf
# from InitFunction and SessionInitFunction
DestroyFunc f_FirstSetup
AddToFunc f_FirstSetup
+ I Test (!x xterm) f_Notifier \
 "Setup Dialog Error" "Dismiss" "NsCDE/Error.xpm" \
 "Error: Cannot continue with initial setup without xterm program. Aborting action."
+ I Test (!x xterm) Break
+ I EdgeThickness 0
+ I SetEnv IVF 1
+ I Exec exec \
    xterm -g 94x26 \
          -fa "scalable=true:spacing=mono:size=16" \
          -bg '#68006f008200' -fg '#ffffffffffff' \
          -title "NsCDE Setup" -name "nscde-setup" \
          -e "$[NSCDE_ROOT]/libexec/nscde_setup"
+ I Schedule 1800 All ("nscde-setup", CirculateHit) AnimatedMove screen c 50-50w 50-50w ewmhiwa
+ I Schedule 2000 All ("nscde-setup", CirculateHit) Layer 0 6
+ I Break

# Called from f_SysResClassEvent
DestroyFunc f_FindIcon
AddToFunc f_FindIcon
+ I Test (I NsCDE/48x48/apps/$[1-].png) \
 WindowId $0 WindowStyle Icon 'NsCDE/48x48/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I 48x48-$[1-].png) \
 WindowId $0 WindowStyle Icon '48x48-$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I NsCDE/32x32/apps/$[1-].png) \
 WindowId $0 WindowStyle Icon 'NsCDE/32x32/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/48x48/apps/$[1-].png) \
 WindowId $0 WindowStyle Icon 'hicolor/48x48/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/48x48/apps/$[1-].xpm) \
 WindowId $0 WindowStyle Icon 'hicolor/48x48/apps/$[1-].xpm'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/scalable/apps/$[1-].svg) \
 WindowId $0 WindowStyle Icon 'hicolor/scalable/apps/$[1-].svg'
+ I TestRc (Match) Break 1
+ I Test (I 32x32-$[1-].png) \
 WindowId $0 WindowStyle Icon '32x32-$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/32x32/apps/$[1-].png) \
 WindowId $0 WindowStyle Icon 'hicolor/32x32/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/32x32/apps/$[1-].xpm) \
 WindowId $0 WindowStyle Icon 'hicolor/32x32/apps/$[1-].xpm'
+ I TestRc (Match) Break 1

# Called from f_SysResClassEvent
DestroyFunc f_FindMiniIcon
AddToFunc f_FindMiniIcon
+ I Test (I NsCDE/16x16/apps/$[1-].png) \
 WindowId $0 WindowStyle MiniIcon 'NsCDE/16x16/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I 16x16-$[1-].png) \
 WindowId $0 WindowStyle MiniIcon '16x16-$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/16x16/apps/$[1-].png) \
 WindowId $0 WindowStyle MiniIcon 'hicolor/16x16/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/16x16/apps/$[1-].xpm) \
 WindowId $0 WindowStyle MiniIcon 'hicolor/16x16/apps/$[1-].xpm'

# Popup Notifications from generated FvwmScript
DestroyFunc f_Notifier
AddToFunc f_Notifier
+ I InfoStoreAdd notif_id ".$4"
+ I Test (EnvMatch infostore.notif_id ".") Current InfoStoreAdd notif_id ".$[w.id]"
+ I Test (EnvMatch infostore.notif_id ".") PipeRead "echo Current InfoStoreAdd notif_id .$[RANDOM]"
+ I All ("NsCDE-Notifier$[infostore.notif_id]", CirculateHit) Break 1
+ I Exec exec mkdir -p "$[FVWM_USERDIR]/tmp"
+ I Exec exec $[NSCDE_ROOT]/libexec/Notifier.sh \
 -t "$0" -b "$1" -i "$2" -s "$3" > $[FVWM_USERDIR]/tmp/NsCDE-Notifier$[infostore.notif_id]
+ I Schedule 250 Module FvwmScript $[FVWM_USERDIR]/tmp/NsCDE-Notifier$[infostore.notif_id]
+ I Schedule 450 Next (NsCDE-Notifier, CirculateHit) WarpToWindow 50 75
+ I Schedule 550 InfoStoreRemove notif_id
+ I Schedule 2500 Exec exec rm -f $[FVWM_USERDIR]/tmp/NsCDE-Notifier$[infostore.notif_id]


##########################################
# Functions called from FvwmEvent MainLoop
##########################################
# Function: f_ChangePage
# Called by: Module FvwmEvent aliased to MainLoop
# Calls:
# 1. f_SendToWSM from Script Functions
DestroyFunc f_ChangePage
AddToFunc f_ChangePage
+ I f_SendToWSM
+ I f_SendToPGM
+ I All (AcceptsFocus, CurrentPage, !Iconic, Focused) FlipFocus NoWarp
+ I TestRc (NoMatch) Prev (AcceptsFocus, CurrentPage, !Iconic) FlipFocus NoWarp
+ I Test (EnvMatch infostore.pageraisefp 1) All ("FrontPanel") Raise
+ I Test (EnvMatch infostore.pageshowrootpager 1) f_ShowLocalPager Move $[infostore.rootpagerposition] ewmhiwa
+ I Test (EnvMatch infostore.desklastpage 1) f_DeskLastPage
+ I f_UserChangePage

# Function: f_ChangeDesk
# Called by: Module FvwmEvent aliased to MainLoop
# Calls:
# 1. f_SendToWsm from Script Functions
DestroyFunc f_ChangeDesk
AddToFunc f_ChangeDesk
+ I f_SendToWSM
+ I Test (EnvMatch infostore.pageshowrootpager 1) \
    Current (FrontPanel, CirculateHit) f_ShowLocalPager Move screen c 50-50w -88p ewmhiwa
+ I Test (EnvMatch infostore.pageshowrootpager 1) \
    Current (!FrontPanel, CirculateHit) f_ShowLocalPager Move $[infostore.rootpagerposition] ewmhiwa
+ I Test (EnvMatch infostore.desklastpage 1) f_DeskLastPage
+ I f_UserChangeDesk

# Function: f_DeskLastPage
# Called if infostore.desklastpage is 1 from f_ChangePage and f_ChangeDesk
# Removes possibility of race condition and double execution.
# Takes no parameters
DestroyFunc f_DeskLastPage
AddToFunc f_DeskLastPage
+ I Test (EnvMatch infostore.desklastpage_done 1) Break
+ I InfoStoreAdd last_page_dsk_$[desk.n] "$[page.nx] $[page.ny]"
+ I InfoStoreAdd lpactive_$[desk.n] 1
+ I InfoStoreAdd desklastpage_done 1
+ I Schedule 100 InfoStoreAdd desklastpage_done 0

# Function: f_SysAddWindowEvent
# Called by: Module FvwmEvent aliased to MainLoop
# Intended to be destroyed and re-added by user local config
DestroyFunc f_SysAddWindowEvent
AddToFunc f_SysAddWindowEvent
+ I Next (GlobalPager,!Transient) f_CenterWindow
+ I Any (CurrentPage,$[w.resource],$[w.class],State 2) Break
+ I WindowId $0 (!FixedSize,!FixedPosition,!State 2) f_GetWinGeometry ResizeMove
+ I WindowId $0 (FixedSize) f_GetWinGeometry f_SafeFvwmCmd Move screen c | cut -d\' \' -f 3,4
+ I WindowId $0 (FixedPosition) f_GetWinGeometry f_SafeFvwmCmd Resize | cut -d\' \' -f 1,2
+ I WindowId $0 (CurrentPage,$[w.resource],$[w.class]) WindowStyle State 2
+ I f_AddWindowEvent $0

# Function: f_SysConfigureWindowEvent
# Called by: Module FvwmEvent aliased to MainLoop
# Intended for selection hilighting of the subpanel Front Panel launchers initially
DestroyFunc f_SysConfigureWindowEvent
AddToFunc f_SysConfigureWindowEvent
+ I WindowId $0 (NsCDE-Subpanel*) f_FrontPanelAction $[w.resource] M1 17
+ I f_ConfigureWindowEvent $0

DestroyFunc f_SysDestroyWindowEvent
AddToFunc f_SysDestroyWindowEvent
+ I Nop
+ I f_DestroyWindowEvent $0

# Called from FvwmEvent MainLoop on "res_class" window manager event.
# This was the least resource triggering and consuming place to put
# Icon and MiniIcon search routines. Can be used for other things in
# the future.
DestroyFunc f_SysResClassEvent
AddToFunc f_SysResClassEvent
+ I InfoStoreAdd iconfile $[w.iconfile]
+ I InfoStoreAdd miniiconfile $[w.miniiconfile]
+ I Test (EnvMatch infostore.iconfile $[NSCDE_ROOT]/share/icons/NsCDE/Noicon.xpm) \
 f_FindIcon $0 $[w.resource]
+ I Test (EnvMatch infostore.miniiconfile $[NSCDE_ROOT]/share/icons/NsCDE/Nominiicon.xpm) \
 f_FindMiniIcon $0 $[w.resource]
+ I InfoStoreRemove iconfile
+ I InfoStoreRemove miniiconfile

# Function: f_FocusChange
# Called from FvwmEvent(1) on focus change
# Serves Style Manager, was serving FrontPanel before
# but now FrontPanel is handled by f_EnterWindow and
# f_LeaveWindow (enter_window and leave_window events
# of the FvwmEvent(1), not by focus_change event).
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_FocusChange
AddToFunc f_FocusChange
+ I f_ChangeIconFocus $0
+ I InfoStoreAdd focus_winname_old "$[infostore.focus_winname_current]"
+ I InfoStoreAdd focus_winname_current $[w.resource]
# + I Test (EnvMatch infostore.focus_winname_old FrontPanel) f_ClearFrontPanelPressed
# + I Test (EnvMatch infostore.focus_winname_current FrontPanel) f_PutFrontPanelPressed
+ I Test (EnvMatch infostore.focus_winname_old "StyleMgr") SendToModule StyleMgr SendString 6 2 hideframe
+ I Test (EnvMatch infostore.focus_winname_current "StyleMgr") SendToModule StyleMgr SendString 6 2 showframe
+ I All (FrontPanel, CirculateHit, !HasPointer) SendToModule WSM SendString 30 2 unselect

# Function: f_ChangeIconFocus
# Called from f_FocusChange which is called from FvwmEvent(1)
DestroyFunc f_ChangeIconFocus
AddToFunc f_ChangeIconFocus
# Parameters: $0 - Window (Icon) ID from FvwmEvent(1)
+ I WindowId $0 (Iconic, Focused, !State 3, !State 4) WindowStyle IconBackgroundColorset 19
+ I WindowId $0 (Iconic, Focused, State 3) WindowStyle IconBackgroundColorset 55
+ I WindowId $0 (Iconic, Focused, State 4) WindowStyle IconBackgroundColorset 57
+ I WindowId $[infostore.lastfocusedicon] (Iconic, !Focused, !State 3, !State 4) WindowStyle IconBackgroundColorset 18
+ I WindowId $[infostore.lastfocusedicon] (Iconic, !Focused, State 3) WindowStyle IconBackgroundColorset 54
+ I WindowId $[infostore.lastfocusedicon] (Iconic, !Focused, State 4) WindowStyle IconBackgroundColorset 56
+ I InfoStoreAdd lastfocusedicon $0

# Function f_EnterWindow 
# Called by the FvwmEvent(1) on enter_window event.
# Currently serves FrontPanel to make it appear as MouseFocus instead of ClickToFocus.
# and to lower/raise FrontPanel in and out of the way during the work.
# Has also user function place holder call on the end.
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_EnterWindow
AddToFunc f_EnterWindow
+ I WindowId $0 (FrontPanel, !Iconic) f_FrontPanelVisualFocus 2 f_PutFrontPanelPressed 0
+ I f_AutoLower FrontPanel 2800
+ I f_AutoRaise FrontPanel 400
+ I f_UserEnterWindow $0

# Function f_LeaveWindow 
# Called by the FvwmEvent(1) on leave_window event.
# Currently serves FrontPanel to make it appear as
# MouseFocus instead of ClickToFocus.
# Has also user function place holder call on the end.
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_LeaveWindow
AddToFunc f_LeaveWindow
+ I WindowId $0 (FrontPanel, !Iconic) f_FrontPanelVisualFocus 1 f_ClearFrontPanelPressed 1
+ I f_UserLeaveWindow $0

# Function: f_IconifyWindow
# Called from FvwmEvent MainLoop instance when window is
# iconified. Initial purpose: change pixmap/colorset for
# icons bigger than cca 60x60.
DestroyFunc f_IconifyWindow
AddToFunc f_IconifyWindow
+ I PipeRead "echo '$[ip.width]$[ip.height]' | egrep -q '^[0-9]+$' || echo 'Break 1'"
+ I PipeRead '(( $[ip.width] > 60 && $[ip.width] < 72 || $[ip.height] > 60 && $[ip.height] < 72 )) && \
 echo "WindowId $0 WindowStyle State 3, IconBackgroundColorset 54"'
+ I PipeRead '(( $[ip.width] >= 72 || $[ip.height] >= 72 )) &&  \
 echo "WindowId $0 WindowStyle State 4, IconBackgroundColorset 56"'

################################
# Functions for generating menus
################################

# Function: f_DeiconifyOnPageMenu
# Generates m_DeiconifyOnPage menu for icons
# which is called from m_IconOps icon menu.
DestroyFunc f_DeiconifyOnPageMenu
AddToFunc f_DeiconifyOnPageMenu
+ I f_SetWSMConf
+ I PipeRead "$NSCDE_ROOT/bin/mkpagemenu $[infostore.pagematrixX] $[infostore.pagematrixY] menu_noicons f_DeiconifyOnPage"

# Top part of the window options menu
DestroyFunc f_WindowOpsBasic
AddToFunc f_WindowOpsBasic
+ I AddToMenu $0 "$[gt.&Refresh]		$[infostore.km_xrefresh]" f_RegenerateWindow
+ I AddToMenu $0 "$[gt.&Move]		$[infostore.km_move]" Move
+ I AddToMenu $0 "$[gt.&Size]		$[infostore.km_resize]" Resize
+ I AddToMenu $0 "$[gt.&Lower]		$[infostore.km_raiselower]" Lower
+ I AddToMenu $0 "$[gt.R&aise]		$[infostore.km_raiselower]" Raise
+ I AddToMenu $0 "$[gt.(De)&Iconify]		$[infostore.km_iconify]" Iconify
+ I AddToMenu $0 "$[gt.(De)S&hade]		$[infostore.km_windowshade]" WindowShade
+ I AddToMenu $0 "$[gt.(Un)Ma&ximize]		$[infostore.km_max_100]" Maximize ewmhiwa
+ I AddToMenu $0 "$[gt.(Un)Stre&tch]		$[infostore.km_max_88]" Maximize

# Part of the window options menu: moving window on workspaces and pages
DestroyFunc f_WindowOpsOccupy
AddToFunc f_WindowOpsOccupy
+ I AddToMenu $0 "$[gt.&Occupy Workspace...]		$[infostore.km_occupyworkspace]" f_SendToOccupyWorkspace
+ I Test (!EnvMatch infostore.pgm 1x1) AddToMenu $0 "$[gt.&Occupy Page...]		$[infostore.km_occupypage]" f_SendToOccupyPage
+ I AddToMenu $0 "$[gt.Occupy &All Workspaces]		$[infostore.km_sticktoggle]" Stick True
+ I AddToMenu $0 "$[gt.&Unoccupy Workspaces]		$[infostore.km_sticktoggle]" Stick False
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Move To Screen ...]" Popup m_MoveToScreen

# Extend window options menu
DestroyFunc f_WindowOpsMore
AddToFunc f_WindowOpsMore
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Extended Menu ...]" Menu m_WindowOpsExtended Context 0+4p o+5
+ I Test (!EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Extended Menu ...]" Menu m_WindowOpsExtended This 0 0

# Reduce extended window options menu to standard menu back
DestroyFunc f_WindowOpsLess
AddToFunc f_WindowOpsLess
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Standard Menu ...]" Menu m_WindowOpsStandard Context 0+4p o+4
+ I Test (!EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Standard Menu ...]" Menu m_WindowOpsStandard This 0 0
+ I AddToMenu $0 "" Nop

# Close window actions: part of the window options menus
DestroyFunc f_WindowOpsClosable
AddToFunc f_WindowOpsClosable
+ I AddToMenu $0 "$[gt.&Delete]		$[infostore.km_delete]" Delete
+ I AddToMenu $0 "$[gt.&Close]		$[infostore.km_close]" Close
+ I AddToMenu $0 "$[gt.Destroy]		$[infostore.km_destroy]" Destroy

# Save and reposition: geometry part of the window options menus
DestroyFunc f_WindowOpsGeometry
AddToFunc f_WindowOpsGeometry
+ I AddToMenu $0 "$[gt.Save &Geometry]		$[infostore.km_savegeom]" f_SaveGeometry
+ I AddToMenu $0 "$[gt.Reposition &Window]		$[infostore.km_reposwin]" f_RepositionWindow

# Extended additions for window options menus
DestroyFunc f_WindowOpsExtended
AddToFunc f_WindowOpsExtended
+ I AddToMenu $0 "$[gt.Title Bar On/Off]		$[infostore.km_toggletitle]" Pick (CirculateHit) f_ToggleWindowStyle Title
+ I AddToMenu $0 "$[gt.Center Window]			$[infostore.km_centerwindow]" Pick (CirculateHit) f_CenterWindow
+ I AddToMenu $0 "$[gt.Window Layers] ..." Popup m_WindowLayers
+ I AddToMenu $0 "$[gt.Identify]" Module FvwmIdent

# Function which generates first button on titlebar window options menu
DestroyFunc f_StandardWindowMenu
AddToFunc f_StandardWindowMenu
+ I DestroyMenu recreate $0
+ I f_WindowOpsBasic $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsOccupy $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsMore $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsClosable $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsGeometry $0
+ I Current f_ExtendCtxMenu1 $0 $[w.class] $[w.resource]

# Function which generates first button on titlebar window options menu
# Extended version activated with "More ..." on Standard window options menu
DestroyFunc f_ExtendedWindowMenu
AddToFunc f_ExtendedWindowMenu
+ I DestroyMenu recreate $0
+ I f_WindowOpsBasic $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsOccupy $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsLess $0
+ I f_WindowOpsExtended $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsClosable $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsGeometry $0
+ I Current f_ExtendCtxMenu2 $0 $[w.class] $[w.resource]

# Special window options menu function for Front Panel
DestroyFunc f_WindowOpsFP
AddToFunc f_WindowOpsFP
+ I AddToMenu $0 "$[gt.&Refresh]		$[infostore.km_xrefresh]" f_RegenerateWindow
+ I AddToMenu $0 "$[gt.&Move]		$[infostore.km_move]" Move
+ I AddToMenu $0 "$[gt.&Size]		$[infostore.km_resize]" Resize
+ I AddToMenu $0 "$[gt.&Lower]		$[infostore.km_raiselower]" Lower
+ I AddToMenu $0 "$[gt.R&aise]		$[infostore.km_raiselower]" Raise
+ I AddToMenu $0 "$[gt.(De)&Iconify]		$[infostore.km_iconify]" Iconify
+ I AddToMenu $0 "$[gt.(De)S&hade]		$[infostore.km_raiseshadefp]" f_RestoreFrontPanel WindowShade South
+ I AddToMenu $0 "$[gt.Reposi&tion]		$[infostore.km_raisefp]" f_RestoreFrontPanel WindowShade Off
+ I AddToMenu $0 "" Nop
+ I AddToMenu $0 "$[gt.&Occupy Workspace...]		$[infostore.km_occupyworkspace]" f_SendToOccupyWorkspace
+ I Test (!EnvMatch infostore.pgm 1x1) AddToMenu $0 "$[gt.&Occupy Page...]		$[infostore.km_occupypage]" f_SendToOccupyPage
+ I AddToMenu $0 "$[gt.Occupy &All Workspaces]		$[infostore.km_sticktoggle]" Stick True
+ I AddToMenu $0 "$[gt.&Unoccupy Workspaces]		$[infostore.km_sticktoggle]" Stick False
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[Move To Screen ...]" Popup m_MoveToScreen
+ I AddToMenu $0 "" Nop
+ I AddToMenu $0 "$[gt.&Close Front Panel]		$[infostore.km_delete]" Current f_CloseFrontPanel $[w.id]
+ I AddToMenu $1 "$[gt.&Move]"	Move
+ I AddToMenu $1 "$[gt.&Lower]"	Lower
+ I AddToMenu $1 "$[gt.R&aise]"	Raise
+ I AddToMenu $1 "$[gt.(De)&Iconify]"	Iconify
+ I AddToMenu $1 "$[gt.&Refresh]"	f_RegenerateWindow
+ I AddToMenu $1 "$[gt.Reposi&tion]"	f_RestoreFrontPanel WindowShade Off
+ I AddToMenu $1 "" Nop
+ I AddToMenu $1 "$[gt.L&og out ...]"	f_RunQuickScriptDialog SysActionDialog 1

DestroyFunc f_SubpanelSettings
AddToFunc f_SubpanelSettings
+ I AddToMenu $0 "Subpanel Settings" Current Module FvwmScript SubpanelSettings $[w.name]

# Fill Applications Menu:
# If there is APPMENU env set, use this as the desktop menu
# If not, check for XDG_CURRENT_DESKTOP, lowercase and use that
# If not, use "--desktop nscde" while generating menus to get
# proper default nscde menu.
DestroyFunc f_ApplicationsMenu
AddToFunc f_ApplicationsMenu
+ I Test (EnvIsSet APPMENU) \
    PipeRead "fvwm-menu-desktop -e --enable-mini-icons \
    --theme NsCDE --insert-in-menu m_Applications --include-items none \
    --app-icon ${NSCDE_ROOT}/share/icons/NsCDE/Nominiicon.xpm --menu-type applications \
    --desktop $[APPMENU] --mini-icon-dir ${FVWM_USERDIR}/icons | \
    ${NSCDE_ROOT}/bin/ised -c \"s/\\(.*%.*\\)Exec exec \\(f_ToggleFvwmModule\\|f_ToggleFvwmFunc\\|f_ToggleExecWindow\\|Module \\)\\(.*\\)/\\1\\2\\3/g\" -o -f -"
+ I TestRc (Match) Break
+ I Test (EnvIsSet XDG_CURRENT_DESKTOP, !EnvMatch XDG_CURRENT_DESKTOP "") \
    PipeRead 'echo $(echo "SetEnv APPMENU "; echo $(echo $XDG_CURRENT_DESKTOP | tr A-Z a-z))'
+ I Test (EnvIsSet APPMENU) \
    PipeRead "fvwm-menu-desktop -e --enable-mini-icons \
    --theme NsCDE --insert-in-menu m_Applications --include-items none \
    --app-icon ${NSCDE_ROOT}/share/icons/NsCDE/Nominiicon.xpm --menu-type applications \
    --desktop $[APPMENU] --mini-icon-dir ${FVWM_USERDIR}/icons | \
    ${NSCDE_ROOT}/bin/ised -c \"s/\\(.*%.*\\)Exec exec \\(f_ToggleFvwmModule\\|f_ToggleFvwmFunc\\|f_ToggleExecWindow\\|Module \\)\\(.*\\)/\\1\\2\\3/g\" -o -f -"
+ I TestRc (Match) Break
+ I TestRc (NoMatch) \
    PipeRead "fvwm-menu-desktop -e --enable-mini-icons \
    --theme NsCDE --insert-in-menu m_Applications --include-items none \
    --app-icon ${NSCDE_ROOT}/share/icons/NsCDE/Nominiicon.xpm --menu-type applications \
    --desktop nscde --mini-icon-dir ${FVWM_USERDIR}/icons | \
    ${NSCDE_ROOT}/bin/ised -c \"s/\\(.*%.*\\)Exec exec \\(f_ToggleFvwmModule\\|f_ToggleFvwmFunc\\|f_ToggleExecWindow\\|Module \\)\\(.*\\)/\\1\\2\\3/g\" -o -f -"
 
DestroyFunc f_IconOps
AddToFunc f_IconOps
+ C Menu m_IconOps Icon +0 -100m Iconify False
+ M Move

# Root Menu small function placeholder for
# double click handling of mouse on root window.
DestroyFunc f_RootMenu
AddToFunc f_RootMenu
+ I Nop
+ D Test (EnvMatch infostore.sandboxmode 0) Menu m_RootMenu mouse -2m -2m
+ D Test (EnvMatch infostore.sandboxmode 1) Menu m_SandboxRootMenu mouse -2m -2m

#######################################################
# Placeholders for functions aimed for user to override
#######################################################
# Called from the CheckMailApplet (left from the WSM on Front Panel)
DestroyFunc f_CheckMail
AddToFunc f_CheckMail
+ I None ("NsCDE-Notifier.f_CheckMail") f_Notifier \
    "Check Mail Function" "Dismiss" "NsCDE/Info.xpm" \
    "$[gt.Write your f_CheckMail function in] $[FVWM_USERDIR]/NsCDE-Functions.local." "f_CheckMail"

# Called from MonthDayApplet (right of the watch on Front Panel)
DestroyFunc f_Calendar
AddToFunc f_Calendar
+ I None ("NsCDE-Notifier.f_Calendar") f_Notifier \
 "Calendar Function" "Dismiss" "NsCDE/Info.xpm" \
 "$[gt.Write your f_Calendar function in] $[FVWM_USERDIR]/NsCDE-Functions.local." "f_Calendar"

# Currently unused.
DestroyFunc f_Mixer
AddToFunc f_Mixer
+ I Test (!x pactl) None ("Audio Mixer Function") f_Notifier \
    "Audio Mixer Function" "Dismiss" "NsCDE/Info.xpm" \
    "$[gt.Write your f_Mixer function in] $[FVWM_USERDIR]/NsCDE-Functions.local."
+ I Test (!x pactl) Break 1
+ I InfoStoreAdd mixeraction $0
+ I Test (EnvMatch infostore.mixeraction -mute) \
    Exec exec pactl set-sink-mute @DEFAULT_SINK@ toggle
+ I Test (EnvMatch infostore.mixeraction -raise) \
    Exec exec pactl set-sink-volume @DEFAULT_SINK@ +$1%
+ I Test (EnvMatch infostore.mixeraction -lower) \
    Exec exec pactl set-sink-volume @DEFAULT_SINK@ -$1%
+ I InfoStoreRemove mixeraction

# Find dialog of user choice
# Intended to be destroyed and recreated by the user
DestroyFunc f_Find
AddToFunc f_Find
+ I Nop

# Function place holder for user additions to root menu
DestroyFunc f_AddCustomToRootMenu
AddToFunc f_AddCustomToRootMenu
+ I Nop

# Called from FvwmEvent MainLoop. Here, user can set
# own hooks to be done when current desk changes.
DestroyFunc f_UserChangeDesk
AddToFunc f_UserChangeDesk
+ I Nop

# Called from FvwmEvent MainLoop. Here, user can set
# own hooks to be done when current page changes.
DestroyFunc f_UserChangePage
AddToFunc f_UserChangePage
+ I Nop

# Hook of the f_SysAddWindowEvent called from
# FvwmEvent on add_window event
DestroyFunc f_AddWindowEvent
AddToFunc f_AddWindowEvent
+ I Nop

# Hook of the f_SysConfigureWindowEvent called from
# FvwmEvent on configure_window event
DestroyFunc f_ConfigureWindowEvent
AddToFunc f_ConfigureWindowEvent
+ I Nop

# Hook of the f_SysDestroyWindowEvent called from
# FvwmEvent on destroy_window event
DestroyFunc f_DestroyWindowEvent
AddToFunc f_DestroyWindowEvent
+ I Nop

# Hook of the RestartFunction called when
# FVWM is restarted.
DestroyFunc f_UserRestartFunction
AddToFunc f_UserRestartFunction
+ I Nop

# Function: f_UserEnterWindow
# Called from f_EnterWindow on mouse hover (FvwmEvent)
# Dummy (Nop) hook intended for local user redefinition.
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_UserEnterWindow
AddToFunc f_UserEnterWindow
+ I Nop

# Function: f_UserLeaveWindow
# Called from f_LeaveWindow on mouse hover (FvwmEvent)
# Dummy (Nop) hook intended for local user redefinition.
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_UserLeaveWindow
AddToFunc f_UserLeaveWindow
+ I Nop

# Intended for user modifications
DestroyFunc f_InitFunction
AddToFunc f_InitFunction
+ I Nop


#####################################
# Functions used in NsCDE FvwmScripts
#####################################

# Function: f_RunQuickScriptDialog
# Center $0 where $0 is a dialog
# Depends on f_AnimatedCenterWarp
# $1 and $2 are coordinates for WarpToWindow used by f_AnimatedCenterWarp
DestroyFunc f_RunQuickScriptDialog
AddToFunc f_RunQuickScriptDialog
+ I None ($0) Module FvwmScript $*
+ I Wait $0
+ I f_AnimatedCenterWarp $0 50 45

# Function: f_SendToOccupyWorkspace
# Calls and sets up OccupyWorkspace Script with fvwm variables
# Depends on: f_RunQuickScriptDialog
DestroyFunc f_SendToOccupyWorkspace
AddToFunc f_SendToOccupyWorkspace
+ I PipeRead "ksh -c 'echo -ne \"InfoStoreAdd desksmenu \"; echo -ne \\\"; \
              for desk in {0..$[infostore.fvwmdesknum]}; \
              do echo -ne "$[desk.name${desk}]"; \
              [ ${desk} != $[infostore.fvwmdesknum] ] && \
              echo -ne \"|\"; done; echo -ne \\\"'"
+ I Module FvwmScript OccupyWorkspace
+ I Wait OccupyWorkspace
+ I SendToModule OccupyWorkspace SendString 9 1 $[w.id] $[w.name]
+ I SendToModule OccupyWorkspace SendString 1 1 $[desk.n]
+ I SendToModule OccupyWorkspace SendString 1 2 $[infostore.desksmenu]

# Function: f_SendToOccupyPage
# Calls and sets up OccupyPage Script with fvwm variables
# Depends on: f_RunQuickScriptDialog
DestroyFunc f_SendToOccupyPage
AddToFunc f_SendToOccupyPage
+ I PipeRead "echo InfoStoreAdd pagesmenu \\\"$($NSCDE_ROOT/bin/mkpagemenu \
              $[infostore.pagematrixX] $[infostore.pagematrixY] pgname | \
              tr '\\n' '|' | sed 's/|$//g')\\\""
+ I Module FvwmScript OccupyPage $[infostore.pagematrixX] $[infostore.pagematrixY]
+ I Wait OccupyPage
+ I SendToModule OccupyPage SendString 9 1 $[w.id] $[w.name]
+ I SendToModule OccupyPage SendString 1 1 $[page.nx] $[page.ny]
+ I SendToModule OccupyPage SendString 1 2 $[infostore.pagesmenu]

# Function: f_Occupy
# Called from OccupyWorkspace and OccupyPage
# $0 = Window Id
# $1 = MoveToDesk or MoveToPage
# $2 = Page or Desk X
# $3 = Page or Desk Y
# $4 = Place holder for GoToDesk and/or GoToPage
DestroyFunc f_Occupy
AddToFunc f_Occupy
+ I WindowId $0 Stick False
+ I WindowId $0 $1 $2 $3
+ I $4 $2 $3

# Without this, WSM does not change it's pressed/unpressed button state
# if desk is changed by some other means. Second SendString is for frame
# around active workspace button.
# Function f_SendToWSM
# WSM Helper
DestroyFunc f_SendToWSM
AddToFunc f_SendToWSM
+ I SendToModule WSM SendString 40 10 $[desk.n]$[page.nx]$[page.ny]
+ I All (FrontPanel, CirculateHit, HasPointer) SendToModule WSM SendString 30 2 unclick

# Unclick Page Manager from itself (visual function only)
# Function f_SendToPGM
# PGM Helper
DestroyFunc f_SendToPGM
AddToFunc f_SendToPGM
+ I SendToModule FrontPanel ChangeButton FpPGM Icon \
    NsCDE/Wsm_$[infostore.pagematrixX]x$[infostore.pagematrixY]_$[page.nx]$[page.ny].xpm

# Function: f_SameWspActionForWSM
# Called by: Workspace Manager when current desk button is clicked
# Calls: f_ShowLocalPager
DestroyFunc f_SameWspActionForWSM
AddToFunc f_SameWspActionForWSM
+ I f_SendToWSM
+ I Test (EnvMatch infostore.pageshowrootpager 0) Break
+ I Current (FrontPanel, CirculateHit) All ("LocalPager") f_ShowLocalPager Move screen c 50-50w -88p ewmhiwa
+ I Current (FrontPanel, CirculateHit) All ("LocalPager", !State 6) WarpToWindow 25 95

# Fplite applet on Front Panel, right top of WSM
# Can be overriden by user if user has some fancy
# app for processes and system resources.
DestroyFunc f_FpLiteClickAction
AddToFunc f_FpLiteClickAction
+ I Test (EnvMatch NSCDE_OS SunOS) Exec exec $[infostore.terminal] -e prstat
+ I TestRc (Match) Break
+ I Test (EnvMatch NSCDE_OS AIX) Exec exec $[infostore.terminal] -e topas
+ I TestRc (Match) Break
+ I Test (x top) Exec exec $[infostore.terminal] -e top
+ I TestRc (Match) Break
+ I None ("FpLite Function Error") f_Notifier \
 "FpLite Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_FpLiteClickAction: Cannot find top(1), prstat(1m) or topas(5) in PATH] $[PATH]."

# SysActionDialog
DestroyFunc f_QuitAndExit
AddToFunc f_QuitAndExit
+ I Test (EnvIsSet SESSION_MANAGER) SetEnv QuitCmd SaveQuitSession
+ I Test (!EnvIsSet SESSION_MANAGER) SetEnv QuitCmd Quit
+ I Echo NsCDE: Quit X Session
+ I Exec exec sync
+ I Test (!EnvIsSet SESSION_MANAGER) Deschedule
+ I Test (!EnvIsSet SESSION_MANAGER) All Delete
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 600 All Close
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 800 All Destroy
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 1200 $[QuitCmd]
+ I Test (EnvIsSet SESSION_MANAGER) Schedule 200 $[QuitCmd]

# SysActionDialog
DestroyFunc f_QuitAndShutdown
AddToFunc f_QuitAndShutdown
+ I Test (EnvIsSet SESSION_MANAGER) SetEnv QuitCmd SaveQuitSession
+ I Test (!EnvIsSet SESSION_MANAGER) SetEnv QuitCmd Quit
+ I Echo NsCDE: Quit and Shutdown
+ I Exec exec sync
+ I Test (!EnvIsSet SESSION_MANAGER) Deschedule
+ I Test (!EnvIsSet SESSION_MANAGER) All Delete
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 600 All Close
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 800 All Destroy
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 1200 Exec exec ksh -c \
 "sudo -n $[NSCDE_ROOT]/libexec/nscde-acpi $0 || $[NSCDE_ROOT]/libexec/nscde-acpi $0"
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 1600 $[QuitCmd]
+ I Test (EnvIsSet SESSION_MANAGER) Exec exec ksh -c \
 "sudo -n $[NSCDE_ROOT]/libexec/nscde-acpi $0 || $[NSCDE_ROOT]/libexec/nscde-acpi $0"
+ I Test (EnvIsSet SESSION_MANAGER) Schedule 400 $[QuitCmd]

# Designed as self-helper for Fvwm Scripts
DestroyFunc f_UnclickScript
AddToFunc f_UnclickScript
+ I Schedule $0 SendToModule $1 SendString $2 $3 $4

