#
# This file is a part of the NsCDE - Not so Common Desktop Environment
# Author: Hegel3DReloaded
# Licence: GPLv3
#

#################################
# Core Window Operation Functions
#################################

# Function: f_GotoDeskAndPage
# Parameters:
# $[*] - desk numbers for child dependent functions
# Changes active Workspace and page to last visited
# on workspace if possible. If not, then changes only
# workspace. Used in WSM and Keybindings as main
# mechanism for workspace navigation.
# If infostore.desklastpage is 0, simply calls GotoDesk
DestroyFunc f_GotoDeskAndPage
AddToFunc f_GotoDeskAndPage
+ I Test (EnvMatch infostore.desklastpage 1, EnvMatch infostore.lpactive_$1 1) GotoDeskAndPage $0$1 $[infostore.last_page_dsk_$1]
+ I Test (EnvMatch infostore.desklastpage 1, !EnvMatch infostore.lpactive_$1 1) GotoDeskAndPage $0$1 0 0
+ I Test (!EnvMatch infostore.desklastpage 1) GotoDesk $[*]

# Function: f_MoveToDeskAndPage
# Moves window to specific desk and page in one call
# similar to GoToDeskAndPage builtin.
DestroyFunc f_MoveToDeskAndPage
AddToFunc f_MoveToDeskAndPage
+ I MoveToDesk $0 $1
+ I MoveToPage $2 $3

# Function: f_GotoDesk
# Wrapper for default NsCDE keybinding Meta+Tab and Meta+Ctrl+LRLR
# Calls GotoDesk and optionally changes page to last active one on desk
# if infostore.desklastpage is 1
# Parameters: none
DestroyFunc f_GotoDesk
AddToFunc f_GotoDesk
+ I GotoDesk $0 $1 $2 $3
+ I Test (EnvMatch infostore.desklastpage 1, EnvMatch infostore.lpactive_$[desk.n] 1) GotoPage $[infostore.last_page_dsk_$[desk.n]]

# Called from Front Panel and Mouse bindings
DestroyFunc f_MoveRaiseLower
AddToFunc f_MoveRaiseLower
+ M Move
+ C RaiseLower
+ D Raise
+ D Move
+ H Raise
+ H Move

# Called from Mouse bindings
# RaiswLower + custom action as $0
DestroyFunc f_RaiseLowerX
AddToFunc f_RaiseLowerX
+ M $0
+ D RaiseLower
+ H Nop

# For Resize / F4, wrapper function
DestroyFunc f_StatefulResize
AddToFunc f_StatefulResize
+ I f_StatefulRestoreMaximize 8 9 10 11 2 Maximize forget
+ I Resize

# Called by CDE Alt+Up and Alt+Down for cycling
# Raise/Lower of overlapped windows on current page
# $0 is Next (Up) or Prev (Down)
DestroyFunc f_FlipOverlappedFocusLR
AddToFunc f_FlipOverlappedFocusLR
+ I $0 (CurrentPage, CirculateHit, Overlapped, AcceptsFocus) Focus NoWarp
+ I $0 (CurrentPage, CirculateHit, Overlapped) RaiseLower

# Cyclink window focus, pointer and visibility on the current
# desk, page or screen
# $0 - Prev or Next or any other condition
# $1 - Usually CurrentDesk, CurrentPage or CurrentScreen
DestroyFunc f_SwithFocus
AddToFunc f_SwitchFocus
+ I $0 ($1, !Iconic, !Focused, AcceptsFocus) Focus NoWarp
+ I $0 ($1, !Iconic, Focused) Raise
+ I $0 ($1, !Iconic, Focused, !HasPointer) WarpToWindow 50 50

# Cycle current desk/page icons selecting them for action
# $1 is for escape function to get back focus of the last
# non-iconified window. Used by Meta+Alt+I and Up/Down/Escape
# in Icon context.
DestroyFunc f_BrowseIcons
AddToFunc f_BrowseIcons
+ I $0 (CurrentPage, $1Iconic, AcceptsFocus) Focus NoWarp
+ I $0 (CurrentPage, $1Iconic, Focused) WarpToWindow 50 50

DestroyFunc f_TileWindows
AddToFunc f_TileWindows
+ I Test (EnvMatch infostore.last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N) \
    All (CurrentPage, !CirculateHit, Maximized) f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I Test (EnvMatch infostore.last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N) \
    f_BreakAfterAction 2 InfoStoreRemove last_pg_winlist
+ I f_CalcWindows last_pg_winlist All CurrentPage, !Iconic, !Shaded, !Transient, !Sticky, !StickyAcrossPages, !StickyAcrossDesks, !CirculateHit
+ I All (CurrentPage, !Iconic, !Shaded, !Transient, !Sticky, !StickyAcrossPages, !StickyAcrossDesks, !CirculateHit) State 9
+ I All (CurrentPage, !CirculateHit, Maximized) f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I Test (EnvMatch infostore.last_pg_winlist 2) \
    Module FvwmRearrange -tile -r -mn 2 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 3) \
    Module FvwmRearrange -tile -r -mn 2 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 4) \
    Module FvwmRearrange -tile -r -mn 2 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 5) \
    Module FvwmRearrange -tile -r -mn 3 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 6) \
    Module FvwmRearrange -tile -r -mn 3 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 7) \
    Module FvwmRearrange -tile -r -mn 3 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 8) \
    Module FvwmRearrange -tile -r -mn 3 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 9) \
    Module FvwmRearrange -tile -r -mn 3 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 10) \
    Module FvwmRearrange -tile -r -mn 4 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 11) \
    Module FvwmRearrange -tile -r -mn 4 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 12) \
    Module FvwmRearrange -tile -r -mn 4 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 13) \
    Module FvwmRearrange -tile -r -mn 4 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 14) \
    Module FvwmRearrange -tile -r -mn 4 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 15) \
    Module FvwmRearrange -tile -r -mn 4 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Test (EnvMatch infostore.last_pg_winlist 16) \
    Module FvwmRearrange -tile -r -mn 4 -maximize 0 0 $[wa.width]p $[wa.height]p
+ I TestRc (Match) f_BreakAfterAction 2 InfoStoreAdd last_pg_winlist $[desk.n]$[page.nx]$[page.ny]N
+ I Module FvwmRearrange -tile -r -maximize 0 0 $[wa.width]p $[wa.height]p

# Called from Mouse bindings and with 3rd TitleBar button
DestroyFunc f_ButtonMaximize
AddToFunc f_ButtonMaximize
+ M ResizeMoveMaximize 75 75 50-50w 50-50w ewmhiwa
+ M State 9 true
+ H Maximize fullscreen
+ C f_StatefulRestoreMaximizeFlip 10 8 9 11 3 Maximize toggle
+ C $0
+ C $1
+ D f_StatefulRestoreMaximizeFlip 11 8 9 10 3 Maximize ewmhiwa
+ D $0
+ D $1

# $0: State to set
# $1 - $3: State to unset
# $4 - Break level to send to f_BreakAfterAction
# $5 - Maximize or any other action
DestroyFunc f_StatefulRestoreMaximize
AddToFunc f_StatefulRestoreMaximize
+ I State $0 true
+ I State $1 false
+ I State $2 false
+ I State $3 false
+ I $[5-]
+ I f_BreakAfterAction $4 Nop

# Make second state significant for f_StatefulRestoreMaximize if we are Maximized
DestroyFunc f_StatefulRestoreMaximizeFlip
AddToFunc f_StatefulRestoreMaximizeFlip
+ I ThisWindow (CirculateHit, !Maximized) f_StatefulRestoreMaximize $0 $1 $2 $3 $4 $[5-]
+ I ThisWindow (CirculateHit, Maximized) f_StatefulRestoreMaximize $1 $0 $2 $3 $4 $[5-]

# For Meta+F8 where we are cycling to every second state (basically toggle operation in 4-way state system)
DestroyFunc f_StatefulRestoreMaximizeJump
AddToFunc f_StatefulRestoreMaximizeJump
+ I ThisWindow (CirculateHit, !Maximized) f_StatefulRestoreMaximize 10 8 9 11 3 Maximize true
+ I ThisWindow (CirculateHit, State 8) f_StatefulRestoreMaximize 10 8 9 11 3 Maximize true
+ I ThisWindow (CirculateHit, Maximized, State 9) f_StatefulRestoreMaximize 11 10 9 8 3 Maximize ewmhiwa true
+ I ThisWindow (CirculateHit, Maximized, State 10) f_StatefulRestoreMaximize 8 11 10 9 3 Maximize false
+ I ThisWindow (CirculateHit, Maximized, State 11) f_GoFromMaxToGrow f_StatefulRestoreMaximize 9 8 10 11 4 Maximize grow grow

# Extended Restore/Maximize function. Cycles between normal, stretched and
# maximized modes in forward (grow) and backward (shrink) directions.
# Grow: f_ExtendedRestoreMaximize grow 9 10 8 true "ewmhiwa true" false
# Shrink: f_ExtendedRestoreMaximize shrink 10 8 9 "ewmhiwa true" false true
# km_max_100 F7 A M f_ExtendedRestoreMaximize shrink 11 8 9 10 "ewmhiwa true" false "grow grow true" true
# km_max_88 F8 A M f_ExtendedRestoreMaximize grow 9 10 11 8 "grow grow true" true "ewmhiwa true" false
DestroyFunc f_ExtendedRestoreMaximize
AddToFunc f_ExtendedRestoreMaximize
+ I InfoStoreAdd maxmin_direction $0
+ I Test ThisWindow (CirculateHit, Maximizable, Maximized) Maximize fullscreen false
+ I Test ThisWindow (CirculateHit, Maximizable, !Maximized, !State 8, !State 9, !State 10, !State 11) State 8
+ I Test ThisWindow (CirculateHit, Maximizable, Maximized, !State 8, !State 9, !State 10, !State 11) State 10
+ I ThisWindow (CirculateHit, Maximizable, State 8) Maximize $5
+ I ThisWindow (CirculateHit, Maximizable, State 9) Maximize $6
+ I Test (EnvMatch infostore.maxmin_direction shrink) ThisWindow (CirculateHit, Maximizable, State 10) f_GoFromMaxToGrow Maximize $7
+ I Test (EnvMatch infostore.maxmin_direction grow) ThisWindow (CirculateHit, Maximizable, State 10) Maximize $7
+ I ThisWindow (CirculateHit, Maximizable, State 11) Maximize $8
+ I ThisWindow (CirculateHit, Maximizable, State 8) f_StateFlipHelper1 $[w.id] $1
+ I ThisWindow (CirculateHit, Maximizable, State 9) f_StateFlipHelper1 $[w.id] $2
+ I ThisWindow (CirculateHit, Maximizable, State 10) f_StateFlipHelper1 $[w.id] $3
+ I ThisWindow (CirculateHit, Maximizable, State 11) f_StateFlipHelper1 $[w.id] $4

# Helper setter of f_ExtendedRestoreMaximize
DestroyFunc f_StateFlipHelper1
AddToFunc f_StateFlipHelper1
+ I WindowId $0 State 8 false
+ I WindowId $0 State 9 false
+ I WindowId $0 State 10 false
+ I WindowId $0 State 11 false
+ I WindowId $0 State $1 true
+ I Break 2

# Helper for shrinking from Stretch to Grow. FVWM Maximize does not understand
# sequence "Maximize true grow grow" when window is already in any maximized
# state. Therefore, we unmaximize window temporary (flickering is a side effect)
# and then we call Maximize grow grow. State 8 true is needed because of last
# resort action from the f_SysConfigureWindowEvent, to avoid last resort.
DestroyFunc f_GoFromMaxToGrow
AddToFunc f_GoFromMaxToGrow
+ I State 8 true
+ I Maximize false
+ I $[0-]

# Do something, then break N levels
# Used in: f_StatefulRestoreMaximize
DestroyFunc f_BreakAfterAction
AddToFunc f_BreakAfterAction
+ I $[1-]
+ I Break $0

# Called from key bindings, and window menu
DestroyFunc f_RegenerateWindow
AddToFunc f_RegenerateWindow
+ I InfoStoreAdd winres $[w.resource]
+ I Test (EnvMatch infostore.winres FrontPanel) f_FullyClearFrontPanelPressed
+ I RefreshWindow

# Used for toggling some Window Style on or off.
DestroyFunc f_ToggleWindowStyle
AddToFunc f_ToggleWindowStyle
+ I ThisWindow (State 1) WindowStyle $[0-]
+ I TestRc (Match) State 1 False
+ I TestRc (Match) Break 1
+ I WindowStyle !$[0-]
+ I State 1 True

# Fill infostore variable with number of matched windows
# $0 Name of the variable wanted to be filled
# $1 Conditional Command
# $[2-] Conditions
DestroyFunc f_CalcWindows
AddToFunc f_CalcWindows
+ I $1 ($[2-]) \
    InfoStoreAdd win.cnt "$[infostore.win.cnt] $[w.id]"
+ I PipeRead \
    'echo InfoStoreAdd $0 $(($(echo \\$[infostore.win.cnt] | wc -w) - 1))'
+ I InfoStoreRemove win.cnt

# Used to center window and warp pointer to exact coordinates, usually 50 50
DestroyFunc f_AnimatedCenterWarp
AddToFunc f_AnimatedCenterWarp
+ I Next ($0, CirculateHit) AnimatedMove screen c 50-50w 50-50w ewmhiwa Warp
+ I Next ($0, CirculateHit) WarpToWindow $1 $2

DestroyFunc f_CenterWindow
AddToFunc f_CenterWindow
+ I ThisWindow Move screen c 50-50w 50-50w ewmhiwa

DestroyFunc f_OverScreen
AddToFunc f_OverScreen
+ I All ($0,CurrentPage,!Iconic) PipeRead '/usr/bin/env ksh93 -c "(( $(($[w.width] + $[w.x])) > $[vp.width] )) || \
                                           (( $(($[w.height] + $[w.y])) > $[vp.height] )) || \
                                           (( $[w.x] < 0 )) || (( $[w.y] < 0 )) && echo State 7"'
+ I All ($0,CurrentPage,State 7) $[1-]
+ I All ($0,CurrentPage,State 7) State 7 false

DestroyFunc f_DeiconifyOnPage
AddToFunc f_DeiconifyOnPage
+ I Iconify False
+ I MoveToPage $0 $1

DestroyFunc f_MoveToPage
AddToFunc f_MoveToPage
+ I f_SetWSMConf
+ I PipeRead '$NSCDE_ROOT/bin/mkpagemenu $[infostore.pagematrixX] $[infostore.pagematrixY] menu_noicons MoveToPage "$[gt.Move To Page]:"'

DestroyFunc f_GoToPage
AddToFunc f_GoToPage
+ I f_SetWSMConf
+ I PipeRead '$NSCDE_ROOT/bin/mkpagemenu $[infostore.pagematrixX] $[infostore.pagematrixY] menu_icons GoToPage'

DestroyFunc f_MoveToWorkspace
AddToFunc f_MoveToWorkspace
+ I f_SetWSMConf
+ I PipeRead 'wsp=0; while [ ${wsp} -lt $[infostore.desknum] ]; do wsp=$((wsp + 1)); \
              wspname=$(egrep "^WSP:${wsp}:" $[infostore.wsmconf] | cut -d: -f3); \
              if [ "x${wspname}" = "x" ]; then wspname="$wsp"; fi; \
              echo "+ \\\"&${wsp} $[gt.Move To Workspace]:		${wspname}\\\" MoveToDesk 0 $(($wsp - 1))"; done'

# For multiscreen in FVWM 2.6.X: better show window on standard position when moved
# Best effort for Gkrellm and stalonetray too. Position are hardcoded for now ...
DestroyFunc f_MoveAllToThisScreen
AddToFunc f_MoveAllToThisScreen
+ I Test (EnvMatch FVWM_IS_FVWM3 1) All MoveToScreen $[monitor.current]
+ I Test (!EnvMatch FVWM_IS_FVWM3 1) All MoveToScreen $[pointer.screen]
+ I Test (EnvMatch infostore.pageshowrootpager 1) f_ShowLocalPager Move $[infostore.rootpagerposition] ewmhiwa
+ I All (Gkrellm, CirculateHit) Move screen c -0 +0
+ I All (stalonetray, CirculateHit) Move screen c -0 -0 ewmhiwa

DestroyFunc f_SaveGeometry
AddToFunc f_SaveGeometry
+ I Pick Nop
+ I PipeRead 'echo InfoStoreAdd window.pos.x $(($[w.x] - $[infostore.lscrn.$[w.screen].pos.x]))'
+ I PipeRead 'echo InfoStoreAdd window.pos.y $(($[w.y] - $[infostore.lscrn.$[w.screen].pos.y]))'
+ I ThisWindow Module FvwmScript GeometryMgr $[infostore.lscrn.$[pointer.screen].width] $[infostore.lscrn.$[pointer.screen].height] $[w.class] $[w.resource] $[infostore.window.pos.x] $[infostore.window.pos.y] $[cw.width] $[cw.height] $[w.miniiconfile]
+ I InfoStoreRemove window.pos.x
+ I InfoStoreRemove window.pos.y

DestroyFunc f_GetWinGeometry
AddToFunc f_GetWinGeometry
+ I PipeRead "echo $0 $1 $($[NSCDE_ROOT]/bin/confget.py \
  -c $[FVWM_USERDIR]/GeoDB.ini \
  -s $[infostore.lscrn.$[pointer.screen].width]x$[infostore.lscrn.$[pointer.screen].height] \
  -k $[w.resource],$[w.class] $[2-])"
+ I Test (EnvMatch infostore.lscrn.sls 1) MoveToScreen $[w.screen]

DestroyFunc f_RepositionWindow
AddToFunc f_RepositionWindow
+ I Current f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I PipeRead "echo InfoStoreAdd wingeo \\\"$($[NSCDE_ROOT]/bin/confget.py -c $[FVWM_USERDIR]/GeoDB.ini \
  -s $[infostore.lscrn.$[pointer.screen].width]x$[infostore.lscrn.$[pointer.screen].height] \
  -k $[w.resource],$[w.class] || echo 0)\\\""
+ I Test (!EnvMatch infostore.wingeo 0) Current (!FixedSize,!FixedPosition) ResizeMove $[infostore.wingeo]
+ I Test (!EnvMatch infostore.wingeo 0) Current (FixedSize) f_RepositionWindowMove $[infostore.wingeo]
+ I Test (!EnvMatch infostore.wingeo 0) Current (FixedPosition) f_RepositionWindowResize $[infostore.wingeo]
+ I Test (EnvMatch infostore.wingeo 0) Current (CirculateHit) PlaceAgain
+ I Test (EnvMatch infostore.lscrn.sls 1) MoveToScreen $[w.screen]
+ I InfoStoreRemove wingeo

DestroyFunc f_RepositionWindowMove
AddToFunc f_RepositionWindowMove
+ I Move $2 $3 

DestroyFunc f_RepositionWindowResize
AddToFunc f_RepositionWindowResize
+ I Resize $1 $2

DestroyFunc f_ZoomInResize
AddToFunc f_ZoomInResize
+ I ThisWindow (CirculateHit, Maximized) f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I ResizeMove w+50p w+50p w-25p w-25p ewmhiwa
+ I ThisWindow (CirculateHit, !Iconic) PlaceAgain

DestroyFunc f_ZoomOutResize
AddToFunc f_ZoomOutResize
+ I ThisWindow (CirculateHit, Maximized) f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I ResizeMove w-50p w-50p w+25p w+25p ewmhiwa
+ I ThisWindow (CirculateHit, !Iconic) PlaceAgain

# Keep part of the keybindings which is common to menus in
# sync with menu declarations of them.
DestroyFunc f_KeyMenu
AddToFunc f_KeyMenu
+ I Piperead "$[NSCDE_ROOT]/libexec/keymenu -a"

# Execute what is in $1 - $X only a second time when
# function is called. Used to make double key bindings
# that will prevent accidental call while typing fast.
DestroyFunc f_DoubleBindKey
AddToFunc f_DoubleBindKey
+ I Test (EnvMatch infostore.dbk_$0 1) $[1-]
+ I Test (!EnvMatch infostore.dbk_$0 1) f_InfoStoreTimeSet $[infostore.menudclicktm] dbk_$0 1

# Middle mouse on titlebar
DestroyFunc f_ScreenShot
AddToFunc f_ScreenShot
+ I f_XdgUserDir PICTURES
+ I Test (x import) Current Exec exec import $0 -window $[w.id] "$[infostore.XDG_PICTURES_DIR]/ScreenShot.$[w.class].$[w.id].$(date +%Y%m%d.%H%M%S).png"
+ I TestRc (NoMatch) Test (x xwd) Current Exec exec xwd $0 -out "$[infostore.XDG_PICTURES_DIR]/ScreenShot.$[w.class].$[w.id].$(date +%Y%m%d.%H%M%S).xwd"
+ I TestRc (NoMatch) None ("NsCDE-Notifier.f_ScreenShot") f_Notifier \
 "Screenshot Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_ScreenShot: No import(1) or xwd(1) for making a screenshot found in PATH] $[PATH]." "f_ScreenShot"

# Middle mouse on titlebar
DestroyFunc f_XwinInfo
AddToFunc f_XwinInfo
+ I Test (x xwininfo) Current Exec exec $[infostore.terminal] -e \
    "/usr/bin/env ksh93 -c 'echo -ne \"\033]0;X Window Info\007\"; xwininfo -all -id $[w.id] | less'"
+ I TestRc (NoMatch) None ("NsCDE-Notifier.f_XwinInfo") f_Notifier \
 "XwinInfo Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_XwinInfo: No xwininfo(1) tool found in PATH] $[PATH]." "f_XwinInfo"

# Middle mouse on titlebar
DestroyFunc f_Xprop
AddToFunc f_Xprop
+ I Test (x xprop) Current Exec exec $[infostore.terminal] -e \
    "/usr/bin/env ksh93 -c 'echo -ne \"\033]0;X Window Properties\007\"; xprop -id $[w.id] | less'"
+ I TestRc (NoMatch) None ("NsCDE-Notifier.f_Xprop") f_Notifier \
 "X Prop Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_Xprop: No xprop(1) tool found in PATH] $[PATH]." "f_Xprop"

# Root Window Screenshot
DestroyFunc f_RootScreenShot
AddToFunc f_RootScreenShot
+ I f_XdgUserDir PICTURES
+ I Test (x import) Schedule $0 Exec exec import -window root "$[infostore.XDG_PICTURES_DIR]/RootWinShot.$(date +%Y%m%d.%H%M%S).png"
+ I TestRc (NoMatch) Test (x xwd) Schedule $0 Exec exec xwd -root -out "$[infostore.XDG_PICTURES_DIR]/RootWinShot.$(date +%Y%m%d.%H%M%S).xwd"
+ I TestRc (NoMatch) None ("NsCDE-Notifier.f_RootScreenShot") f_Notifier \
 "Root Screenshot Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_RootScreenShot: No import(1) or xwd(1) for making a root window screenshot found in PATH] $[PATH]." \
 "f_RootScreenShot"

# Screen Area Screenshot
DestroyFunc f_AreaScreenShot
AddToFunc f_AreaScreenShot
+ I Test (!x import) None ("NsCDE-Notifier.f_AreaScreenShot") f_Notifier \
 "Area Screenshot Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_AreaScreenShot: No import(1) ImageMagick command found for making screen area screenshot. PATH:] $[PATH]." \
 "f_AreaScreenShot"
+ I Test (!x import) Break 1
+ I f_XdgUserDir PICTURES
+ I Test (x import) Schedule 250 Exec exec import "$[infostore.XDG_PICTURES_DIR]/ScreenAreaShot.WSP_$[desk.name$[desk.n]].$(date +%Y%m%d.%H%M%S).png"

# Slight modification of the builting WindowListFunc
# Last two lines are signalization for Break in f_WinLists
DestroyFunc f_WindowList
AddToFunc f_WindowList
+ I Iconify False
+ I FlipFocus
+ I Raise
+ I WarpToWindow 50-50w 50-50w
+ I Test (EnvMatch infostore.wlisttype G) InfoStoreAdd wlistsig G
+ I Test (EnvMatch infostore.wlisttype L) InfoStoreAdd wlistsig L
+ I Test (EnvMatch infostore.desklastpage 1) InfoStoreAdd last_page_dsk_$[desk.n] "$[page.nx] $[page.ny]"

# Local and Global Window List toggle call
# Called with Alt+Escape keybinding.
# 1. It Schedules turn back on the start state on 1.25 seconds.
# 2. Puts WindowList type to (L)ocal if it is not set (initial)
# 3a. If WindowList type is (L)ocal, popup local WindowList with refefined function
# 3b. Put (G)lobal as WindowList type
# 3c. Breaks from function if WindowList signature is (L)ocal
# 4. If WindowList type is (G)lobal, popup global WindowList
DestroyFunc f_WinLists
AddToFunc f_WinLists
+ I Schedule 1250 InfoStoreAdd wlisttype L
+ I Schedule 1250 InfoStoreAdd wlistsig G
+ I Test (!EnvMatch infostore.wlisttype L) \
    Test (!EnvMatch infostore.wlisttype G) InfoStoreAdd wlisttype L
+ I Test (EnvMatch infostore.wlisttype L) \
    WindowList Root c c NoGeometry TitleForAllDesks NoCurrentDeskTitle \
    NoNumInDeskTitle CurrentDesk Function f_WindowList
+ I Test (EnvMatch infostore.wlisttype L) InfoStoreAdd wlisttype G
+ I Test (EnvMatch infostore.wlistsig L) Break
+ I Test (EnvMatch infostore.wlisttype G) WindowList Root c c NoGeometry \
    TitleForAllDesks NoCurrentDeskTitle NoNumInDeskTitle Function f_WindowList

# Function: f_MouseWinList
# Adds ability to remember last page when positoned from
# WindowList called from mouse click. Doesn't take any parameters.
DestroyFunc f_MouseWinList
AddToFunc f_MouseWinList
+ I Iconify False
+ I FlipFocus
+ I Raise
+ I WarpToWindow 10p 10p
+ I Test (EnvMatch infostore.desklastpage 1) InfoStoreAdd last_page_dsk_$[desk.n] "$[page.nx] $[page.ny]"

# Function: f_SafeFvwmCmd
# Purpose: run fvwm command only if it has some arguments
# used in f_SysAddWindowEvent while calling f_GetWinGeometry
# Parameters: $0 - Fvwm command, $[1-], arguments
DestroyFunc f_SafeFvwmCmd
AddToFunc f_SafeFvwmCmd
+ I InfoStoreAdd fvwmcmdargs "A$[1-]Z"
+ I Test (!EnvMatch infostore.fvwmcmdargs AZ) $0 $[1-]
+ I InfoStoreRemove infostore.fvwmcmdargs

#######################
# Front Panel functions
#######################

# Set number of left and right launchers
# Called directly from NsCDE-FrontPanel.conf
DestroyFunc f_FpConfigLaunchers
AddToFunc f_FpConfigLaunchers
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 0) InfoStoreAdd fpleft ""
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 1) InfoStoreAdd fpleft "L1"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 2) InfoStoreAdd fpleft "L1 L2"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 3) InfoStoreAdd fpleft "L1 L2 L3"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 4) InfoStoreAdd fpleft "L1 L2 L3 L4"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 5) InfoStoreAdd fpleft "L1 L2 L3 L4 L5"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 6) InfoStoreAdd fpleft "L1 L2 L3 L4 L5 L11"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 7) InfoStoreAdd fpleft "L1 L2 L3 L4 L5 L11 L12"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 8) InfoStoreAdd fpleft "L1 L2 L3 L4 L5 L11 L12 L13"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 9) InfoStoreAdd fpleft "L1 L2 L3 L4 L5 L11 L12 L13 L14"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum 10) InfoStoreAdd fpleft "L1 L2 L3 L4 L5 L11 L12 L13 L14 L15"
+ I Test (EnvMatch infostore.FP.LeftLaunchersNum) InfoStoreAdd fpleft "L1 L2 L3 L4 L5"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 0) InfoStoreAdd fpright ""
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 1) InfoStoreAdd fpright "R6"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 2) InfoStoreAdd fpright "R6 R7"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 3) InfoStoreAdd fpright "R6 R7 R8"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 4) InfoStoreAdd fpright "R6 R7 R8 R9"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 5) InfoStoreAdd fpright "R6 R7 R8 R9 R10"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 6) InfoStoreAdd fpright "R6 R7 R8 R9 R10 R16"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 7) InfoStoreAdd fpright "R6 R7 R8 R9 R10 R16 R17"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 8) InfoStoreAdd fpright "R6 R7 R8 R9 R10 R16 R17 R18"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 9) InfoStoreAdd fpright "R6 R7 R8 R9 R10 R16 R17 R18 R19"
+ I Test (EnvMatch infostore.FP.RightLaunchersNum 10) InfoStoreAdd fpright "R6 R7 R8 R9 R10 R16 R17 R18 R19 R20"
+ I InfoStoreAdd FP.Launchers-Enabled "$[infostore.fpleft] $[infostore.fpright]"
+ I InfoStoreRemove infostore.fpleft
+ I InfoStoreRemove infostore.fpright

DestroyFunc f_AddRemoveLauncher
AddToFunc f_AddRemoveLauncher
+ I PipeRead "$[NSCDE_ROOT]/libexec/fp_manage_subpanel $0 $1"
+ I f_RestartFrontPanel

DestroyFunc f_RestartFrontPanel
AddToFunc f_RestartFrontPanel
+ I f_InfoStoreTimeSet 5500 no_fp_colorset_change 1
+ I KillModule FvwmButtons FrontPanel
+ I PipeRead "$[NSCDE_ROOT]/libexec/fpseticon pre"
+ I f_Readcfg FrontPanel
+ I ModuleSynchronous Timeout 5 FvwmButtons FrontPanel
+ I f_SendToPGM
+ I Test (EnvMatch infostore.wsmcolored 1) Schedule 100 SendToModule FrontPanel ChangeButton FpWSM Colorset 22

DestroyFunc f_RestoreFrontPanel
AddToFunc f_RestoreFrontPanel
+ I None (FvwmButtons,FrontPanel,CirculateHit) InfoStoreAdd _initfp 1
+ I Test (EnvMatch infostore._initfp 1) f_ReadCfg FrontPanel
+ I Test (EnvMatch infostore._initfp 1) f_InfoStoreTimeSet 5500 no_fp_colorset_change 1
+ I Test (EnvMatch infostore._initfp 1) ModuleSynchronous Timeout 5 FvwmButtons FrontPanel
+ I Test (EnvMatch infostore._initfp 1, EnvMatch infostore.wsmcolored 1) Schedule 100 SendToModule FrontPanel ChangeButton FpWSM Colorset 22
+ I Test (EnvMatch infostore._initfp 1) InfoStoreRemove _initfp
+ I All (FvwmButtons,FrontPanel,CirculateHit,Iconic) Iconify False
+ I All (FvwmButtons,FrontPanel,CirculateHit,!Sticky) Stick
+ I All (FvwmButtons,FrontPanel,CirculateHit) $0 $1
+ I All (FvwmButtons,FrontPanel,CirculateHit) RaiseLower
+ I All (FvwmButtons,FrontPanel,CirculateHit) Resize $[infostore.FP.Columns]p 79p
+ I All (FvwmButtons,FrontPanel,CirculateHit) AnimatedMove screen c 50-50w -0p ewmhiwa
+ I All (FvwmButtons,FrontPanel,CirculateHit) Focus
+ I Test (EnvMatch infostore.fp_needs_ptr 1) All (FvwmButtons,FrontPanel,CirculateHit,!HasPointer,!Shaded) WarpToWindow 50 50
+ I Test (EnvMatch infostore.fp_needs_ptr 1) InfoStoreAdd fp_needs_ptr 0
+ I All (FvwmButtons,FrontPanel,CirculateHit,!HasPointer) InfoStoreAdd fp_needs_ptr 1
+ I Test (EnvMatch FVWM_IS_FVWM3 1) f_SendToWSM
+ I Test (EnvMatch FVWM_IS_FVWM3 1) Schedule 250 f_SendToPGM
+ I Test (EnvMatch FVWM_IS_FVWM3 1) Schedule 1250 f_SendToPGM

DestroyFunc f_KeyFromFpToSubanel
AddToFunc f_KeyFromFpToSubanel
+ I Test (!EnvMatch infostore.$0-Enabled 1) Break
+ I None ($0) SendToModule FrontPanel PressButton $0
+ I None ($0) Wait $0
+ I Schedule 250 All ($0) WarpToWindow 50 50
+ I Schedule 2000 Break

DestroyFunc f_KeyFromSubpanelToFP
AddToFunc f_KeyFromSubpanelToFP
+ I Test (!EnvMatch infostore.$0-Enabled 1) Break
+ I All ($0) SendToModule FrontPanel PressButton $0
+ I All (FrontPanel, CirculateHit, !HasPointer) WarpToWindow 50 50

# We must call fvwm-menu-desktop here to regenerate local icon cache just in case
DestroyFunc f_RefreshSubpanel
AddToFunc f_RefreshSubpanel
+ I Exec exec fvwm-menu-desktop --mini-icon-dir $[FVWM_USERDIR]/icons --enable-mini-icons -s 32 --theme NsCDE --include-items none > /dev/null 2>&1
+ I PipeRead "$[NSCDE_ROOT]/libexec/generate_subpanels > $[FVWM_USERDIR]/NsCDE-Subpanels.conf 2> /dev/null"
+ I f_ReadCfg Subpanels
+ I KillModule FvwmButtons $0
+ I SendToModule FrontPanel PressButton $0
+ I Schedule 800 SendToModule FrontPanel PressButton $0
+ I Schedule 3200 Exec exec $[NSCDE_ROOT]/bin/xdowrapper

# Front Panel functions f_FrontPanelAction and f_FrontPanelActionStyler
# must be separated because f_FrontPanelActionStyler is called by very
# active configure_window event handled by f_SysMapEvent,
# so any PipeRead or Exec can have significant impact on performance.
DestroyFunc f_FrontPanelAction
AddToFunc f_FrontPanelAction
+ I Piperead "$[NSCDE_ROOT]/libexec/fpexec $0 $1"
+ I f_FrontPanelActionStyler $0 $1 $2

DestroyFunc f_FrontPanelActionStyler
AddToFunc f_FrontPanelActionStyler
+ I InfoStoreAdd fpcurrent $0
+ I Test (EnvMatch infostore.fplastpressed Btn*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 23
+ I Test (EnvMatch infostore.fplastpressed FpLite, !EnvMatch infostore.fpcurrent FpLite) SendToModule FpLite SendString 1 2 unselect
+ I Test (EnvMatch infostore.fplastpressed FpWSM) SendToModule $[infostore.WSM] SendString 30 2 unselect
+ I Test (EnvMatch infostore.fplastpressed FpPGM) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 23
+ I Test (EnvMatch infostore.fplastpressed FpLock) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 23
+ I Test (EnvMatch infostore.fplastpressed FpExit) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 23
+ I Test (EnvMatch infostore.fplastpressed NsCDE-Subpanel*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 1
+ I Schedule 100 SendToModule FrontPanel ChangeButton $0 Colorset $2
+ I InfoStoreAdd fplastpressed $0

DestroyFunc f_FrontPanelMenuAction
AddToFunc f_FrontPanelMenuAction
+ I Piperead "$[NSCDE_ROOT]/libexec/fpexec $0 $1"

DestroyFunc f_FrontPanelPropsMenu
AddToFunc f_FrontPanelPropsMenu
+ I DestroyMenu m_FrontPanelPropsMenu
+ I AddToMenu m_FrontPanelPropsMenu " $[1-] " Title
+ I AddToMenu m_FrontPanelPropsMenu "$[1-]" SendToModule FrontPanel PressButton Btn$0
+ I AddToMenu m_FrontPanelPropsMenu "" Nop
+ I AddToMenu m_FrontPanelPropsMenu "$[gt.Reset This Button]" Exec exec $[NSCDE_ROOT]/libexec/fp_manage_subpanel -p $0 -r $[infostore.FP.Btn$0.type]
+ I AddToMenu m_FrontPanelPropsMenu "" Nop
+ I Test (EnvMatch infostore.NsCDE-Subpanel$0-Enabled 1) \
    AddToMenu m_FrontPanelPropsMenu "$[gt.Reset Subpanel]" \
    f_RunQuickScriptDialog ActionForm \
    "$[gt.Do you want to reset Subpanel] $0 $[gt.to default configuration?]" \
    $[gt.Yes] $[gt.No] "$[gt.Subpanel Reset Confirmation]" "f_ResetSubpanel $0" Nop
+ I Test (EnvMatch infostore.NsCDE-Subpanel$0-Enabled 0) \
    AddToMenu m_FrontPanelPropsMenu "$[gt.Add Subpanel]" \
    f_FrontPanelManageSubpanels $0 -a
+ I Test (EnvMatch infostore.NsCDE-Subpanel$0-Enabled 1) \
    AddToMenu m_FrontPanelPropsMenu "$[gt.Delete Subpanel]" \
    f_FrontPanelManageSubpanels $0 -d
+ I AddToMenu m_FrontPanelPropsMenu "" Nop
+ I AddToMenu m_FrontPanelPropsMenu "$[gt.Help]" f_DisplayURL "$[gt.Front Panel Help]" $[NSCDE_ROOT]/share/doc/html/NsCDE-applets-docks-panels.html
+ I ChangeMenuStyle CommonAppMenu m_FrontPanelPropsMenu
+ I Popup m_FrontPanelPropsMenu mouse -0m -0m

DestroyFunc f_FrontPanelManageSubpanels
AddToFunc f_FrontPanelManageSubpanels
+ I Exec exec $[NSCDE_ROOT]/libexec/fp_manage_subpanel -p $0 $1
+ I Exec exec $[NSCDE_ROOT]/libexec/generate_subpanels > $[FVWM_USERDIR]/NsCDE-Subpanels.conf
+ I Schedule 800 f_ReadCfg Subpanels
+ I Schedule 1200 f_RestartFrontPanel

DestroyFunc f_SubpanelPropsMenu
AddToFunc f_SubpanelPropsMenu
+ I DestroyMenu m_SubpanelPropsMenu
+ I AddToMenu m_SubpanelPropsMenu " $2 " Title
+ I AddToMenu m_SubpanelPropsMenu "$2" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -e
+ I AddToMenu m_SubpanelPropsMenu "" Nop
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Move Up]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -a up
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Move Down]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -a down
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Move to Beginning]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -a begin
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Move to End]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -a end
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Copy to Main Panel]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -c $[infostore.FP.Btn$0.type]
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Delete]" Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -t "$2" -d
+ I AddToMenu m_SubpanelPropsMenu "" Nop
+ I AddToMenu m_SubpanelPropsMenu "$[gt.Help]" f_DisplayURL "$[gt.Subpanels Help]" $[NSCDE_ROOT]/share/doc/html/NsCDE-Subpanels.html
+ I ChangeMenuStyle CommonAppMenu m_SubpanelPropsMenu
+ I Popup m_SubpanelPropsMenu mouse -0m -0m

DestroyFunc f_DeleteFromSubpanel
AddToFunc f_DeleteFromSubpanel
+ I Exec exec $[NSCDE_ROOT]/libexec/subpanel_menuitem_props -p $0 -s $1 -a delete

DestroyFunc f_SubpanelItemExec
AddToFunc f_SubpanelItemExec
+ I SendToModule $0 ChangeButton $[infostore.subpanel_$0_last_sel_id] Colorset 49
+ I SendToModule $0 ChangeButton $1 Colorset 16
+ I InfoStoreAdd subpanel_$0_last_sel_id $1
+ I InfoStoreAdd last_subpanel $0
+ I $[2-]

DestroyFunc f_ResetSubpanel
AddToFunc f_ResetSubpanel
+ I Test (R $[FVWM_USERDIR]/Subpanels.actions) \
    Exec exec $[NSCDE_ROOT]/bin/ised -c '/^S$0,\(NAME\|WIDTH\|ENABLED\|ENTRY\),.*/d' -f $[FVWM_USERDIR]/Subpanels.actions
+ I Schedule 400 f_RefreshSubpanel NsCDE-Subpanel$0

# Called from f_FocusChange FvwmEvent MainLoop - this
# clears selected state for Front Panel and Style Manager
# buttons when their windows are not in focus.
# Break 1 is here to allow continuation in second level
# function f_FullyClearFrontPanelPressed
DestroyFunc f_ClearFrontPanelPressed
AddToFunc f_ClearFrontPanelPressed
+ I Test (EnvMatch infostore.fplastpressed Btn*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 23
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed NsCDE-Subpanel*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 1
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpExit) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 23
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpWSM) SendToModule $[infostore.WSM] SendString 30 2 unselect
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpLite) SendToModule FpLite SendString 1 2 unselect
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpPGM) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 23
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpLock) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 23

# Middle click on handle of the Front Panel clears selected state
# for all buttons.
DestroyFunc f_FullyClearFrontPanelPressed
AddToFunc f_FullyClearFrontPanelPressed
+ I f_ClearFrontPanelPressed
+ I InfoStoreRemove fplastpressed

# Called from f_FocusChange FvwmEvent MainLoop - this
# sets back selected state for Front Panel and Style Manager
# buttons when their windows are focused.
DestroyFunc f_PutFrontPanelPressed
AddToFunc f_PutFrontPanelPressed
+ I Test (EnvMatch infostore.fplastpressed Btn*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 29
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed NsCDE-Subpanel*) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 17
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpExit) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 30
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpWSM) SendToModule $[infostore.WSM] SendString 30 2 unclick
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpLite) SendToModule FpLite SendString 1 2 unclick
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpPGM) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 30
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.fplastpressed FpLock) SendToModule FrontPanel ChangeButton $[infostore.fplastpressed] Colorset 30

# Function: f_FrontPanelVisualFocus
# This function serves FrontPanel to make it appear as
# MouseFocus instead of ClickToFocus.
# Called by: f_LeaveWindow
# $0 = BorderColorset
# $1 = FrontPanel function (f_ClearFrontPanelPressed or f_PutFrontPanelPressed)
# $2 = InfoStoreAdd fp_event_leave - either 0 or 1
DestroyFunc f_FrontPanelVisualFocus
AddToFunc f_FrontPanelVisualFocus
+ I CursorStyle WAIT left_ptr
+ I f_ToggleWindowStyle BorderColorset $0
+ I $1
+ I Schedule 250 CursorStyle WAIT cursors/WaitCursor.xpm
+ I InfoStoreAdd fp_event_leave $2

DestroyFunc f_EmptyFrontPanelLauncher
AddToFunc f_EmptyFrontPanelLauncher
+ I f_Notifier "$[gt.New Front Panel Button] ($[0])" "Dismiss" "NsCDE/Info.xpm" \
  "$[gt.To assign action and icon to this button, add Subpanel above it, and then \
press \\\"Install Icon\\\" Subpanel item to launch Subpanels Manager and add some \
application to that Subpanel. Next, copy that application item to the Main Panel. \
Finally, either keep or disable Subpanel above the button. Alternatively, \
~/.NsCDE/FrontPanel.actions file can be manually edited and assigment of icon and \
command to the button can be configured there.]" "FP_Lnch_Notice_$[0]"

# Function: f_CloseFrontPanel
# Used in: f_WindowOpsFPBtn1 menu generator function
DestroyFunc f_CloseFrontPanel
AddToFunc f_CloseFrontPanel
+ I KillModule FvwmButtons FrontPanel
+ I Deschedule $0
+ I Schedule 100 Deschedule $0
+ I Schedule 200 Deschedule $0

#################################################
# Helper Functions used by FvwmAuto and FvwmEvent
#################################################
# Function f_AutoShadeAction
# Helper function of f_AutoShade
DestroyFunc f_AutoShadeAction
AddToFunc f_AutoShadeAction
+ I Schedule $0 $[w.id]ff01 WindowId $[w.id] WindowShade $1 $2
+ I Schedule $0 $[w.id]ff01 Deschedule $[w.id]ff01

# Function: f_AutoShade
# FvwmAuto function which automatically shades window
DestroyFunc f_AutoShade
AddToFunc f_AutoShade
+ I ThisWindow ($0) Deschedule $[w.id]ff01
+ I ThisWindow ($0) KeepRc ThisWindow (Shaded) WindowShade off
+ I TestRc (NoMatch) All ($0, !Shaded) f_AutoShadeAction $1 $2 $3

# Function f_AutoIconifyAction
# Helper function of f_AutoIconify
DestroyFunc f_AutoIconifyAction
AddToFunc f_AutoIconifyAction
+ I Schedule $0 $[w.id]ff02 Iconify on $1
+ I Schedule $0 $[w.id]ff02 Deschedule $[w.id]ff02

# Function: f_AutoIconify
# FvwmAuto function which automatically (de)iconifies window
DestroyFunc f_AutoIconify
AddToFunc f_AutoIconify
+ I ThisWindow ($0) Deschedule $[w.id]ff02
+ I ThisWindow ($0) KeepRc ThisWindow (Iconified) Iconify toggle
+ I TestRc (!Match) All ($0, !Iconified, !HasPointer) f_AutoIconifyAction $1

# Function f_AutoDeleteAction
# Helper function of f_AutoDelete
DestroyFunc f_AutoDeleteAction
AddToFunc f_AutoDeleteAction
+ I Schedule $0 $[w.id]ff03 Delete $1
+ I Schedule $0 $[w.id]ff03 Deschedule $[w.id]ff03

# Function: f_AutoDelete
# FvwmAuto function which automatically deletes window
DestroyFunc f_AutoDelete
AddToFunc f_AutoDelete
+ I ThisWindow ($0) Deschedule $[w.id]ff03
+ I ThisWindow ($0) KeepRc ThisWindow (HasPointer) Nop
+ I TestRc (Match) All ($0, !HasPointer) f_AutoDeleteAction $1

# Function f_AutoRaiseAction
# Helper function of f_AutoRaise
DestroyFunc f_AutoRaiseAction
AddToFunc f_AutoRaiseAction
+ I Schedule $0 $[w.id]ff04 Raise $1
+ I Schedule $0 $[w.id]ff04 Deschedule $[w.id]ff04

# Function: f_AutoRaise
# FvwmAuto function which automatically raises window
DestroyFunc f_AutoRaise
AddToFunc f_AutoRaise
+ I ThisWindow ($0) Deschedule $[w.id]ff04
+ I ThisWindow ($0) KeepRc Schedule $1 $[w.id] ThisWindow (HasPointer) Raise
+ I TestRc (!Match) All ($0, HasPointer) f_AutoRaiseAction $1

# Function f_AutoLowerAction
# Helper function of f_AutoLower
DestroyFunc f_AutoLowerAction
AddToFunc f_AutoLowerAction
+ I Schedule $0 $[w.id]ff05 Lower $1
+ I Schedule $0 $[w.id]ff05 Deschedule $[w.id]ff05

# Function: f_AutoLower
# FvwmAuto function which automatically lowers window
DestroyFunc f_AutoLower
AddToFunc f_AutoLower
+ I ThisWindow ($0) Deschedule $[w.id]ff05
+ I ThisWindow ($0) KeepRc ThisWindow (!HasPointer) Lower
+ I TestRc (!Match) All ($0, Raised, !HasPointer) f_AutoLowerAction $1

# Function f_AutoRefreshWindowAction
# Helper function of f_AutoRefreshWindow
DestroyFunc f_AutoRefreshWindowAction
AddToFunc f_AutoRefreshWindowAction
+ I Schedule $0 $[w.id]ff06 Raise $1
+ I Schedule $0 $[w.id]ff06 Deschedule $[w.id]ff06

# Function: f_AutoRefreshWindow
# FvwmAuto function which automatically refreshes window
DestroyFunc f_AutoRefreshWindow
AddToFunc f_AutoRefreshWindow
+ I ThisWindow ($0) Deschedule $[w.id]ff06
+ I ThisWindow ($0) KeepRc Schedule $1 $[w.id] ThisWindow (HasPointer) RefreshWindow
+ I TestRc (!Match) All ($0, HasPointer) f_AutoRefreshWindowAction $1


#####################
# Misc core functions
#####################

# Called from NsCDE-Main.conf during startup
# This is "init script" for Local Pager
DestroyFunc f_StartLocalPager
AddToFunc f_StartLocalPager
+ I All ("LocalPager") Break 1
+ I Module FvwmPager LocalPager * $[infostore.fvwmdesknum]
+ I Wait LocalPager
+ I All ("LocalPager") State 6
+ I All ("LocalPager", State 6) Schedule 1000 Move +32768p +32768p
+ I Test (EnvMatch FVWM_IS_FVWM3 1) InfoStoreAdd localpager.monitor $[monitor.current]

DestroyFunc f_RestartLocalPager
AddToFunc f_RestartLocalPager
+ I Test (EnvMatch infostore.localpager.monitor $[monitor.current]) Break 1
+ I Deschedule 131313
+ I All (LocalPager, CirculateHit) Style LocalPager InitialMapCommand Move $[infostore.rootpagerposition] ewmhiwa
+ I KillModule FvwmPager LocalPager
+ I Module FvwmPager LocalPager * $[infostore.fvwmdesknum]
+ I Next (LocalPager, CirculateHit) State 6 true
+ I InfoStoreAdd localpager.monitor $[monitor.current]

# Local Pager positioning (if configured)
# $[0-] is usually Move xxx yyy or AnimatedMove xxx yyy
# Depends on: f_HideLocalPager
DestroyFunc f_ShowLocalPager
AddToFunc f_ShowLocalPager
+ I Test (EnvMatch FVWM_IS_FVWM3 1) f_RestartLocalPager
+ I All ("LocalPager", !State 6) f_Reschedule Periodic 1250 131313 All ("LocalPager", !HasPointer, !State 6) f_HideLocalPager
+ I PointerWindow ("FrontPanel", CirculateHit) All ("LocalPager", !State 6) $[0-]
+ I All ("LocalPager", !State 6) Break 1
+ I All (CurrentPage, GlobalPager) Break 1
+ I Deschedule 131313
+ I All ("LocalPager", State 6) State 6 False
+ I All ("LocalPager") Raise
+ I PointerWindow (!"LocalPager") All ("LocalPager", !State 6) $[0-]
+ I TestRc (Error) All ("LocalPager", !State 6) $[0-]
+ I Schedule Periodic 1250 131313 All ("LocalPager", !HasPointer, !State 6) f_HideLocalPager

# Local Pager hiding (if configured)
# Depends on: f_DescheduleAfterAction
DestroyFunc f_HideLocalPager
AddToFunc f_HideLocalPager
+ I f_DescheduleAfterAction 131313 Move +32768p +32768p
+ I All ("LocalPager") State 6 toggle

DestroyFunc f_KeyShowLocalPager
AddToFunc f_KeyShowLocalPager
+ I InfoStoreRemove dbk_localpager
+ I f_ShowLocalPager $[0-]
+ I All ("LocalPager", CirculateHit, !Transient) f_OverScreen LocalPager PlaceAgain
+ I All ("LocalPager", CirculateHit, !Transient) WarpToWindow 50 50

# Setup Global Pager Function
# $0 is for -transient argument
DestroyFunc f_ShowGlobalPager
AddToFunc f_ShowGlobalPager
+ I Test (EnvMatch infostore.dbk_globalpager 1) InfoStoreRemove dbk_globalpager
+ I All (GlobalPager, !Iconic, !Shaded, State 5) KillModule FvwmPager GlobalPager
+ I All (GlobalPager, Iconic, State 5) Iconify false
+ I All (GlobalPager, Shaded, State 5) WindowShade false
+ I All (GlobalPager, !State 5) f_NonTransientPager
+ I All (GlobalPager) Break 1
+ I All (CurrentPage, "LocalPager", !Iconic) Iconify True
+ I All ("WspLocPager") KillModule FvwmPager WspLocPager
+ I InfoStoreAdd gp_opts "$[0-]"
+ I Test (EnvMatch infostore.gp_opts -transient) \
    Module FvwmPager $[infostore.gp_opts] GlobalPager 0 $[infostore.fvwmdesknum]
+ I Test (!EnvMatch infostore.gp_opts -transient) \
    Module FvwmPager GlobalPager 0 $[infostore.fvwmdesknum]
+ I Wait GlobalPager
+ I All ("GlobalPager", CirculateHit, !Transient) $[infostore.gp_opts]
+ I All ("GlobalPager", CirculateHit, !Transient) f_OverScreen GlobalPager PlaceAgain
+ I All ("GlobalPager", CirculateHit, !Transient) WarpToWindow 50 50
+ I Schedule Periodic 1250 141414 \
    All ("GlobalPager", !State 5, !HasPointer, CirculateHit, !Transient) \
    f_DescheduleAfterAction 141414 KillModule FvwmPager GlobalPager

DestroyFunc f_NonTransientPager
AddToFunc f_NonTransientPager
+ I State 5 toggle
+ I State 1 toggle
+ I f_ToggleWindowStyle Title
+ I WindowStyle IconOverride, Icon NsCDE/GWM.l.xpm, MiniIcon NsCDE/GWM.t.xpm, WindowListHit, Button 4

# This uses catalogue of possible applications from $NSCDE_ROOT/share/fallback/app-catalog/
# It defines terminal, filemgr, xeditor and such if NsCDE.conf does not defines them.
DestroyFunc f_FindApp
AddToFunc f_FindApp
+ I Test (x $[infostore.$$0]) Break 1
+ I Test (!f $[NSCDE_ROOT]/share/fallback/app-catalog/$1) f_Notifier \
                  "$[gt.App Finder]" \
                  "$[gt.Dismiss]" \
                  "NsCDE/Error.xpm" \
                  "$[gt.Error: Application Catalog] $1 $[gt.for defining] \\\"$0\\\" $[gt.does not exist]."
+ I PipeRead "echo InfoStoreAdd $0 \"$($[NSCDE_ROOT]/libexec/appfinder $1)\""
+ I Test (!Init, !Restart, EnvMatch infostore.$$0 "NOAPP") f_Notifier \
                  "App Finder" \
                  "Dismiss" \
                  "NsCDE/Error.xpm" \
                  "$[gt.Error defining] \\\"$0\\\" $[gt.automatic default: cannot find any usable application.]"
+ I Test (!EnvMatch infostore.$$0 "NOTFOUND") Echo NsCDE: Selected default for $0: $[infostore.$$0]

DestroyFunc f_WideTerm
AddToFunc f_WideTerm
+ I Current (*term*,Maximized) Maximize false
+ I TestRc (NoMatch) Current (*term*) \
    PipeRead \
    "echo ResizeMoveMaximize $((($[infostore.lscrn.$[w.screen].width] / 100) * 75))p \
      $((($[infostore.lscrn.$[w.screen].height] / 100) * 75))p $((50 / $[infostore.lscrn.cnt]))-50w -100p ewmhiwa"
+ I TestRc (Match) MoveToScreen c
+ I TestRc (Match) State 9
+ I TestRc (Match) Break
+ I Current (*Term*,Maximized) Maximize false
+ I TestRc (NoMatch) Current (*Term*) \
    PipeRead \
    "echo ResizeMoveMaximize $((($[infostore.lscrn.$[w.screen].width] / 100) * 75))p \
      $((($[infostore.lscrn.$[w.screen].height] / 100) * 75))p $((50 / $[infostore.lscrn.cnt]))-50w -100p ewmhiwa"
+ I TestRc (Match) MoveToScreen c
+ I TestRc (Match) State 9
+ I TestRc (Match) Break
+ I Current (*xvt*,Maximized) Maximize false
+ I TestRc (NoMatch) Current (*xvt*) \
    PipeRead \
    "echo ResizeMoveMaximize $((($[infostore.lscrn.$[w.screen].width] / 100) * 75))p \
      $((($[infostore.lscrn.$[w.screen].height] / 100) * 75))p $((50 / $[infostore.lscrn.cnt]))-50w -100p ewmhiwa"
+ I TestRc (Match) MoveToScreen c
+ I TestRc (Match) State 9

# If the window exists, points the pointer to it. If it does not exists,
# Checks for program existance, removes arg1 and arg2 and execes the rest.
# Parameters: $0 - Window Name or Class Name, $1, binary to check for in PATH
# $2/$* - the rest of the command line.
DestroyFunc f_WarpOrExec
AddToFunc f_WarpOrExec
+ I Next ($0, CirculateHit) WarpToWindow 50 50
+ I TestRc (NoMatch) None ($0) Test (x $1) Exec exec $[2-]

# Exec program if it is not present, move to page/desk if present
# elseware, close if $1 is Close and present + visible on the current page.
DestroyFunc f_ToggleExecWindow
AddToFunc f_ToggleExecWindow
+ I None ($0,CirculateHit) Exec exec $[2-]
+ I Next ($0,CirculateHit,CurrentPage,Visible) $1
+ I Next ($0,CirculateHit) MoveToDesk
+ I Next ($0,CirculateHit) MoveToPage
+ I Next ($0,CirculateHit) Raise

# Spawn FVWM module if it is not present, move to page/desk if present
# elseware, kill module if present and visible on the current page.
# Function name referenced in SubpanelMgr
DestroyFunc f_ToggleFvwmModule
AddToFunc f_ToggleFvwmModule
+ I None ($1,CirculateHit) Module $[0-]
+ I Next ($1,CirculateHit,CurrentPage,Visible) KillModule $0 $1
+ I Next ($1,CirculateHit) MoveToDesk
+ I Next ($1,CirculateHit) MoveToPage
+ I Next ($1,CirculateHit) Raise

# Execute FVWM function if $0 is not present, warp to window if present
# elseware, do $1 with $0 if $0 is present + visible on the current page.
# Function name referenced in SubpanelMgr
DestroyFunc f_ToggleFvwmFunc
AddToFunc f_ToggleFvwmFunc
+ I None ($0,CirculateHit) $[2-]
+ I Next ($0,CirculateHit,CurrentPage,Visible) $1
+ I Next ($0,CirculateHit) WarpToWindow 50 50
+ I Next ($0,CirculateHit) Raise

# Function which moves mouse in some direction before calling a command
# or another function. Used to move mouse from edge of the screen before
# calling things which are positioning themselves near the pointer position.
DestroyFunc f_MoveCursorAndExec
AddToFunc f_MoveCursorAndExec
+ I CursorMove $0 $1
+ I $[2-]

# Xscreensaver management
DestroyFunc f_Xscreensaver
AddToFunc f_Xscreensaver
+ I Test (!x xscreensaver-command) None ("NsCDE-Notifier.f_Xscreensaver_1") f_Notifier \
    "Screensaver Error" "Dismiss" "NsCDE/Error.xpm" \
    "$[gt.Cannot find] \\\"xscreensaver-command\\\" $[gt.in PATH] $[PATH]." "f_Xscreensaver_1"
+ I TestRc (Match) Break
+ I Test (!EnvMatch infostore.nscde_use_xscreensaver 1) None ("NsCDE-Notifier.f_Xscreensaver_2") f_Notifier \
    "Screensaver Error" "Dismiss" "NsCDE/Error.xpm" \
    "Screensaver has been disabled in configuration. See \\\"nscde_use_xscreensaver\\\" in your NsCDE.conf." "f_Xscreensaver_2"
+ I TestRc (Match) Break
+ I InfoStoreAdd xsc_cmd $0
+ I PipeRead "echo InfoStoreAdd xsc_status A$(pgrep -u $[USER] xscreensaver)O"
+ I Test (EnvMatch infostore.xsc_status "AO", !EnvMatch infostore.xsc_cmd "-restart", !EnvMatch infostore.xsc_cmd "-start") f_Notifier \
    "Screensaver Error" "Dismiss" "NsCDE/Warning.xpm" \
    "$[gt.No X Screen Saver (xscreensaver) is running on display] $[DISPLAY]. $[gt.Attempting to start it and re-execute f_Xscreensaver] $0."
+ I Test (EnvMatch infostore.xsc_status "AO") Exec exec xscreensaver -no-splash
+ I Test (EnvMatch infostore.xsc_status "AO") Schedule 1000 f_Xscreensaver $0
+ I Test (EnvMatch infostore.xsc_status "AO") Break 1
+ I Test (EnvMatch infostore.xsc_cmd -stop) Exec exec pkill -STOP -u $[USER] -xf "xscreensaver(.*)?"
+ I Test (EnvMatch infostore.xsc_cmd -stop) SendToModule FrontPanel ChangeButton FpLock Icon NsCDE/FplockSuspended.s.pm
+ I Test (EnvMatch infostore.xsc_cmd -stop) InfoStoreAdd xsc_status "Alck_disabledO"
+ I Test (EnvMatch infostore.xsc_cmd -cont) Exec exec pkill -CONT -u $[USER] -xf "xscreensaver(.*)?"
+ I Test (EnvMatch infostore.xsc_cmd -cont) SendToModule FrontPanel ChangeButton FpLock Icon NsCDE/FpLock.xpm
+ I Test (EnvMatch infostore.xsc_cmd -cont) InfoStoreAdd xsc_status "Alck_enabledO"
+ I Test (EnvMatch infostore.xsc_cmd -lock) Exec exec xscreensaver-command $0
+ I Test (EnvMatch infostore.xsc_cmd -prefs) Exec exec xscreensaver-command $0
+ I Test (EnvMatch infostore.xsc_cmd -restart) Exec exec pkill -u $[USER] xscreensaver
+ I Test (EnvMatch infostore.xsc_cmd -restart) Schedule 1000 Exec exec xscreensaver -no-splash
+ I Test (EnvMatch infostore.xsc_cmd -restart) Schedule 1200 InfoStoreAdd xsc_status "Alck_enabledO"
+ I Test (EnvMatch infostore.xsc_cmd -start) Schedule 1000 Exec exec xscreensaver -no-splash
+ I Test (EnvMatch infostore.xsc_cmd -start) Schedule 1200 InfoStoreAdd xsc_status "Alck_enabledO"
+ I Test (EnvMatch infostore.xsc_cmd -kill) Exec exec pkill -u $[USER] -xf "xscreensaver(.*)?"
+ I Test (EnvMatch infostore.xsc_cmd -kill) InfoStoreAdd xsc_status "Alck_disabledO"

# Standalone XSETTINGS daemon xsettingsd support
DestroyFunc f_Xsettingsd
AddToFunc f_Xsettingsd
+ I Test (!EnvMatch infostore.nscde_use_xsettingsd 1) Break 1
+ I Test (!x xsettingsd) Break 1
+ I Test (EnvMatch infostore.nscde_use_xsettingsd 1, !r $[FVWM_USERDIR]/Xsettingsd.conf) \
    Exec exec cp -f $[NSCDE_ROOT]/share/config_templates/Xsettingsd.conf $[FVWM_USERDIR]/Xsettingsd.conf
+ I Test (!r $[FVWM_USERDIR]/Xsettingsd.conf) Break 1
+ I InfoStoreAdd xsettingsd_action $0
+ I Test (EnvMatch infostore.xsettingsd_action start) Exec exec /usr/bin/env ksh93 -c 'pkill -u "$[USER]" xsettingsd; exec xsettingsd -c $[FVWM_USERDIR]/Xsettingsd.conf'
+ I Test (EnvMatch infostore.xsettingsd_action restart) Exec exec /usr/bin/env ksh93 -c 'pkill -u "$[USER]" xsettingsd; exec xsettingsd -c $[FVWM_USERDIR]/Xsettingsd.conf'
+ I Test (EnvMatch infostore.xsettingsd_action reload) Exec exec pkill -HUP -u "$[USER]" xsettingsd
+ I Test (EnvMatch infostore.xsettingsd_action stop) Exec exec pkill -u "$[USER]" xsettingsd
+ I Test (EnvMatch infostore.xsettingsd_action status) PipeRead "echo Echo $(pgrep -u $[USER] xsettingsd)"
+ I InfoStoreRemove xsettingsd_action

# Standalone Tray daemon stalonetray support
DestroyFunc f_Stalonetray
AddToFunc f_Stalonetray
+ I Test (!EnvMatch infostore.nscde_use_stalonetray 1) Break 1
+ I Test (!x stalonetray) Break 1
+ I Test (EnvMatch infostore.nscde_use_stalonetray 1, !r $[FVWM_USERDIR]/Stalonetray.conf) \
    Exec exec cp -f $[NSCDE_ROOT]/share/config_templates/Stalonetray.conf $[FVWM_USERDIR]/Stalonetray.conf
+ I Test (!r $[FVWM_USERDIR]/Stalonetray.conf) Break 1
+ I InfoStoreAdd stalonetray_action $0
+ I Test (EnvMatch infostore.stalonetray_action start) Exec exec /usr/bin/env ksh93 -c 'pkill -u "$[USER]" stalonetray; exec stalonetray -c $[FVWM_USERDIR]/Stalonetray.conf'
+ I Test (EnvMatch infostore.stalonetray_action restart) Exec exec /usr/bin/env ksh93 -c 'pkill -u "$[USER]" stalonetray; exec stalonetray -c $[FVWM_USERDIR]/Stalonetray.conf'
+ I Test (EnvMatch infostore.stalonetray_action stop) Exec exec pkill -u "$[USER]" stalonetray
+ I Test (EnvMatch infostore.stalonetray_action status) PipeRead "echo Echo $(pgrep -u $[USER] stalonetray)"
+ I InfoStoreRemove stalonetray_action

# Standalone notification daemon dunst support
DestroyFunc f_Dunst
AddToFunc f_Dunst
+ I Test (!EnvMatch infostore.nscde_use_dunst 1) Break 1
+ I Test (!x dunst) Break 1
+ I Test (EnvMatch infostore.nscde_use_dunst 1, !r $[FVWM_USERDIR]/Dunst.conf) \
    Exec exec cp -f $[NSCDE_ROOT]/share/config_templates/Dunst.conf $[FVWM_USERDIR]/Dunst.conf
+ I Test (!r $[FVWM_USERDIR]/Dunst.conf) Break 1
+ I InfoStoreAdd dunst_action $0
+ I Test (EnvMatch infostore.dunst_action start) Exec exec /usr/bin/env ksh93 -c 'pkill -u "$[USER]" dunst; exec dunst -config $[FVWM_USERDIR]/Dunst.conf'
+ I Test (EnvMatch infostore.dunst_action restart) Exec exec /usr/bin/env ksh93 -c 'pkill -u "$[USER]" dunst; exec dunst -config $[FVWM_USERDIR]/Dunst.conf'
+ I Test (EnvMatch infostore.dunst_action stop) Exec exec pkill -u "$[USER]" dunst
+ I Test (EnvMatch infostore.dunst_action status) PipeRead "echo Echo $(pgrep -u $[USER] dunst)"
+ I InfoStoreRemove dunst_action

# For displaying documentation purposes, or sending URL to web browser
DestroyFunc f_DisplayURL
AddToFunc f_DisplayURL
+ I Echo Sending Link $1 from $0 to $[infostore.browser]
+ I Module FvwmScript WaitNotice "$0" "$[gt.Sending Link to] $[infostore.browser]" " ... " 1800
+ I Exec exec $[infostore.browser] $1

# FVWM Version check function - usually called on init
DestroyFunc f_FvwmVersionCheck
AddToFunc f_FvwmVersionCheck
+ I Test (EnvMatch FVWM_IS_FVWM3 1) Break 1
+ I Test (Version >= 2.6.7) Break 1
+ I Test (Version < 2.6.7) f_Notifier \
 "NsCDE: FVWM Version Check" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.FVWM version] $[version.num] $[gt.is not supported by NsCDE] $[NSCDE_VERSION] \
 $[gt.(FVWM 2.6.7 is the oldest supported and tested version).] \
 $[gt.Functional problems, misbehaviour and unpredictable behaviour can be expected if this session is going to continue.] \
 $[gt.Please install and use newer FVWM version. Logout, or continue with a risk.]"

# Make a small time frame for action repeat to succeed.
# Used for Front Panel subpanels enablement currently
# $0 - name part of the infostore variable to set
# $1 - schedule time in milliseconds
# $2 - the rest of the command line
DestroyFunc f_DoubleClickExec
AddToFunc f_DoubleClickExec
+ I Test (EnvMatch infostore.$0 1) $2
+ I TestRc (Match) Break
+ I Test (!EnvMatch infostore.$0 1) f_InfoStoreTimeSet $1 $0 1

# Deschedule action $0 after $[1-] is finally executed
# Initially created for f_ShowLocalPager
DestroyFunc f_DescheduleAfterAction
AddToFunc f_DescheduleAfterAction
+ I $[1-]
+ I Deschedule $0

# f_Reschedule
# Deschedule identified action and schedule it again
# Initially created for f_ShowLocalPager
DestroyFunc f_Reschedule
AddToFunc f_Reschedule
+ I InfoStoreAdd sched_type $0
+ I Test (EnvMatch infostore.sched_type Periodic) Deschedule $2
+ I Test (!EnvMatch infostore.sched_type Periodic) Deschedule $1
+ I Schedule $[0-]
+ I InfoStoreRemove sched_type

# First Run Setup Function
# Called from config/NsCDE-Init.conf
# from InitFunction and SessionInitFunction
DestroyFunc f_FirstSetup
AddToFunc f_FirstSetup
+ I Test (!x xterm) f_Notifier \
 "Setup Dialog Error" "Dismiss" "NsCDE/Error.xpm" \
 "Error: Cannot continue with initial setup without xterm program. Aborting action."
+ I Test (!x xterm) Break
+ I EdgeThickness 0
+ I SetEnv IVF 1
+ I Exec exec \
    xterm -g 94x26 \
          -fa "scalable=true:spacing=mono:size=16" \
          -bg '#68006f008200' -fg '#ffffffffffff' \
          -title "NsCDE Setup" -name "nscde-setup" \
          -e "$[NSCDE_ROOT]/libexec/nscde_setup"
+ I Test (EnvMatch FVWM_IS_FVWM3 1) Schedule 1800 All ("nscde-setup", CirculateHit) Maximize fullscreen
+ I Test (!EnvMatch FVWM_IS_FVWM3 1, Version >= 2.6.8) Schedule 1800 All ("nscde-setup", CirculateHit) Maximize fullscreen
+ I Test (!EnvMatch FVWM_IS_FVWM3 1, Version < 2.6.8) Schedule 1800 All ("nscde-setup", CirculateHit) Maximize ewmhiwa
+ I Schedule 2000 All ("nscde-setup", CirculateHit) Layer 0 6
+ I Break

# Called from f_SysResClassEvent
DestroyFunc f_FindIcon
AddToFunc f_FindIcon
+ I Test (I NsCDE/48x48/apps/$[1-].png) \
 WindowId $0 WindowStyle Icon 'NsCDE/48x48/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I 48x48-$[1-].png) \
 WindowId $0 WindowStyle Icon '48x48-$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I NsCDE/32x32/apps/$[1-].png) \
 WindowId $0 WindowStyle Icon 'NsCDE/32x32/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/48x48/apps/$[1-].png) \
 WindowId $0 WindowStyle Icon 'hicolor/48x48/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/48x48/apps/$[1-].xpm) \
 WindowId $0 WindowStyle Icon 'hicolor/48x48/apps/$[1-].xpm'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/scalable/apps/$[1-].svg) \
 WindowId $0 WindowStyle Icon 'hicolor/scalable/apps/$[1-].svg'
+ I TestRc (Match) Break 1
+ I Test (I 32x32-$[1-].png) \
 WindowId $0 WindowStyle Icon '32x32-$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/32x32/apps/$[1-].png) \
 WindowId $0 WindowStyle Icon 'hicolor/32x32/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/32x32/apps/$[1-].xpm) \
 WindowId $0 WindowStyle Icon 'hicolor/32x32/apps/$[1-].xpm'
+ I TestRc (Match) Break 1

# Called from f_SysResClassEvent
DestroyFunc f_FindMiniIcon
AddToFunc f_FindMiniIcon
+ I Test (I NsCDE/16x16/apps/$[1-].png) \
 WindowId $0 WindowStyle MiniIcon 'NsCDE/16x16/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I 16x16-$[1-].png) \
 WindowId $0 WindowStyle MiniIcon '16x16-$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/16x16/apps/$[1-].png) \
 WindowId $0 WindowStyle MiniIcon 'hicolor/16x16/apps/$[1-].png'
+ I TestRc (Match) Break 1
+ I Test (I hicolor/16x16/apps/$[1-].xpm) \
 WindowId $0 WindowStyle MiniIcon 'hicolor/16x16/apps/$[1-].xpm'

# Popup Notifications from generated FvwmScript
DestroyFunc f_Notifier
AddToFunc f_Notifier
+ I InfoStoreAdd notif_id ".$4"
+ I Test (EnvMatch infostore.notif_id ".") Current InfoStoreAdd notif_id ".$[w.id]"
+ I Test (EnvMatch infostore.notif_id ".") PipeRead "echo Current InfoStoreAdd notif_id .$[RANDOM]"
+ I All ("NsCDE-Notifier$[infostore.notif_id]", CirculateHit) Break 1
+ I Exec exec mkdir -p "$[FVWM_USERDIR]/tmp"
+ I Exec exec $[NSCDE_ROOT]/libexec/Notifier.sh \
 -t "$0" -b "$1" -i "$2" -s "$3" > $[FVWM_USERDIR]/tmp/NsCDE-Notifier$[infostore.notif_id]
+ I Schedule 250 Module FvwmScript $[FVWM_USERDIR]/tmp/NsCDE-Notifier$[infostore.notif_id]
+ I Schedule 450 Next (NsCDE-Notifier, CirculateHit) WarpToWindow 50 75
+ I Schedule 550 InfoStoreRemove notif_id
+ I Schedule 2500 Exec exec rm -f $[FVWM_USERDIR]/tmp/NsCDE-Notifier$[infostore.notif_id]

# Iconify non-iconic group of iconifiable windows on the current screen/desk/page
DestroyFunc f_CleanWorkspace
AddToFunc f_CleanWorkspace
+ I SendToModule FvwmAnimate push pause
+ I PipeRead 'for iwin in $[1-]; do echo "WindowId $iwin Iconify on"; done'
+ I SendToModule FvwmAnimate pop
+ I InfoStoreAdd sdpstat-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny] restore
+ I Break

# Deiconify non-iconic group of iconifiable windows on the current screen/desk/page
# which was previously iconified as a group on that page by f_CleanWorkspace
DestroyFunc f_RestoreWorkspace
AddToFunc f_RestoreWorkspace
+ I SendToModule FvwmAnimate push pause
+ I PipeRead 'for iwin in $[1-]; do echo "WindowId $iwin (Iconic) Iconify off"; done'
+ I SendToModule FvwmAnimate pop
+ I InfoStoreAdd sdpstat-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny] hide
+ I Break

# Fill local infostore variables for screen/desktop/page combination
# and Flip Flop f_CleanWorkspace and f_RestoreWorkspace
DestroyFunc f_CleanRestoreWorkspace
AddToFunc f_CleanRestoreWorkspace
+ I Test (EnvMatch infostore.sdpstat-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny] hide) \
 InfoStoreRemove sdp-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny]
+ I All UseStack Reverse (CurrentPage, Iconifiable, !Iconic, !CirculateHit) \
    PipeRead 'echo InfoStoreAdd sdp-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny] \
              \\"\\$[infostore.sdp-\\$[pointer.screen]\\$[desk.n]\\$[page.nx]\\$[page.ny]] \$[w.id]\\"'
+ I Test (EnvMatch infostore.sdpstat-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny] hide) \
 f_CleanWorkspace $[infostore.sdp-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny]]
+ I Test (EnvMatch infostore.sdpstat-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny] restore) \
 f_RestoreWorkspace $[infostore.sdp-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny]]
+ I f_CleanWorkspace $[infostore.sdp-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny]]


##########################################
# Functions called from FvwmEvent MainLoop
##########################################
# Function: f_ChangePage
# Called by: Module FvwmEvent aliased to MainLoop
# Calls:
# 1. f_SendToWSM from Script Functions
DestroyFunc f_ChangePage
AddToFunc f_ChangePage
+ I f_SendToWSM
+ I f_SendToPGM
+ I All (AcceptsFocus, CurrentPage, !Iconic, Focused) FlipFocus NoWarp
+ I TestRc (NoMatch) Prev (AcceptsFocus, CurrentPage, !Iconic) FlipFocus NoWarp
+ I Test (EnvMatch infostore.pageraisefp 1) All ("FrontPanel") Raise
+ I Test (EnvMatch infostore.pageshowrootpager 1) f_ShowLocalPager Move $[infostore.rootpagerposition] ewmhiwa
+ I Test (EnvMatch infostore.desklastpage 1) f_DeskLastPage
+ I f_UserChangePage

# Function: f_ChangeDesk
# Called by: Module FvwmEvent aliased to MainLoop
# Calls:
# 1. f_SendToWsm from Script Functions
DestroyFunc f_ChangeDesk
AddToFunc f_ChangeDesk
+ I Test (EnvMatch FVWM_IS_FVWM3 1, !EnvMatch infostore.desktopconfiguration "global", EnvIsSet infostore.monitor2.name) f_SetFvwm3NonGlobalBackground
+ I f_SendToWSM
+ I Test (EnvMatch infostore.pageshowrootpager 1, !EnvMatch infostore.pgm 1x1) \
    Current (FrontPanel, CirculateHit) f_ShowLocalPager Move screen c 50-50w -88p ewmhiwa
+ I Test (EnvMatch infostore.pageshowrootpager 1, !EnvMatch infostore.pgm 1x1) \
    Current (!FrontPanel, CirculateHit) f_ShowLocalPager Move $[infostore.rootpagerposition] ewmhiwa
+ I PointerWindow
+ I TestRc (-1) f_ShowLocalPager Move $[infostore.rootpagerposition] ewmhiwa
+ I Test (EnvMatch infostore.desklastpage 1, !EnvMatch infostore.pgm 1x1) f_DeskLastPage
+ I f_UserChangeDesk

# FVWM3 internal function RandRFunc is run when a screen event occurs
# such as enabling/disabling/resolution change.
DestroyFunc RandRFunc
AddToFunc RandRFunc
+ I Schedule 5200 f_SetupMonitorData

# Function: f_SetupMonitorData
# Called by: RandRFunc
# Purpose: On RandR monitor configuration change, clean up previous relevant infostore variables
# and set it up again when active monitors are detected. For example, infostore variables which
# are handing actual RandR monitor names, and constructing monitor.data infostore variables which
# are used by f_SetFvwm3NonGlobalBackground to find and/or compose joined backgrounds depending on
# which desktops are combined on separate monitors.
DestroyFunc f_SetupMonitorData
AddToFunc f_SetupMonitorData
+ I Echo "Recalculating Monitors and their FVWM3 and NsCDE settings."
+ I PipeRead '$[NSCDE_ROOT]/libexec/nscde_get_logical_screens'
+ I Test (!EnvMatch infostore.desktopconfiguration "global", !EnvIsSet infostore.monitor2.name) ModuleSynchronous FvwmBacker
+ I Test (!EnvMatch infostore.desktopconfiguration "global", EnvIsSet infostore.monitor2.name) KillModule FvwmBacker

# Function: f_SetFvwm3NonGlobalBackground
# Called by: f_ChangeDesk (if FVWM3 is detected)
# Purpose: construct "monitordata" infostore variable which holds all monitor
# info (WxH+x+y, desk background and monitor<->desk info), create strings which
# are valid input for fvwm-root and/or $[NSCDE_ROOT]/libexec/xrandr_backer if
# backdrop mapping does not exist as a file yet.
DestroyFunc f_SetFvwm3NonGlobalBackground
AddToFunc f_SetFvwm3NonGlobalBackground
+ I InfoStoreAdd monitordata ' '
+ I InfoStoreAdd monitorbackdata ' '
+ I Test (EnvIsSet infostore.monitor1.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitor1.data]/$[monitor.$[infostore.monitor1.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor1.name].desk].backinfo]"
+ I Test (EnvIsSet infostore.monitor1.name) \
    InfoStoreAdd monitorbackdata "$[infostore.fvwmdesk.$[monitor.$[infostore.monitor1.name].desk].back]"
+ I Test (EnvIsSet infostore.monitor2.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitordata]+$[infostore.monitor2.data]/$[monitor.$[infostore.monitor2.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor2.name].desk].backinfo]
+ I Test (EnvIsSet infostore.monitor2.name) \
    InfoStoreAdd monitorbackdata "$[infostore.monitorbackdata]+$[infostore.fvwmdesk.$[monitor.$[infostore.monitor2.name].desk].back]"
+ I Test (EnvIsSet infostore.monitor3.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitordata]+$[infostore.monitor3.data]/$[monitor.$[infostore.monitor3.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor3.name].desk].backinfo]
+ I Test (EnvIsSet infostore.monitor3.name) \
    InfoStoreAdd monitorbackdata "$[infostore.monitorbackdata]+$[infostore.fvwmdesk.$[monitor.$[infostore.monitor3.name].desk].back]"
+ I Test (EnvIsSet infostore.monitor4.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitordata]+$[infostore.monitor4.data]/$[monitor.$[infostore.monitor4.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor4.name].desk].backinfo]
+ I Test (EnvIsSet infostore.monitor4.name) \
    InfoStoreAdd monitorbackdata "$[infostore.monitorbackdata]+$[infostore.fvwmdesk.$[monitor.$[infostore.monitor4.name].desk].back]"
+ I Test (EnvIsSet infostore.monitor5.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitordata]+$[infostore.monitor5.data]/$[monitor.$[infostore.monitor5.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor5.name].desk].backinfo]
+ I Test (EnvIsSet infostore.monitor5.name) \
    InfoStoreAdd monitorbackdata "$[infostore.monitorbackdata]+$[infostore.fvwmdesk.$[monitor.$[infostore.monitor5.name].desk].back]"
+ I Test (EnvIsSet infostore.monitor6.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitordata]+$[infostore.monitor6.data]/$[monitor.$[infostore.monitor6.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor6.name].desk].backinfo]
+ I Test (EnvIsSet infostore.monitor6.name) \
    InfoStoreAdd monitorbackdata "$[infostore.monitorbackdata]+$[infostore.fvwmdesk.$[monitor.$[infostore.monitor6.name].desk].back]"
+ I Test (EnvIsSet infostore.monitor7.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitordata]+$[infostore.monitor7.data]/$[monitor.$[infostore.monitor7.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor7.name].desk].backinfo]
+ I Test (EnvIsSet infostore.monitor7.name) \
    InfoStoreAdd monitorbackdata "$[infostore.monitorbackdata]+$[infostore.fvwmdesk.$[monitor.$[infostore.monitor7.name].desk].back]"
+ I Test (EnvIsSet infostore.monitor8.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitordata]+$[infostore.monitor8.data]/$[monitor.$[infostore.monitor8.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor8.name].desk].backinfo]
+ I Test (EnvIsSet infostore.monitor8.name) \
    InfoStoreAdd monitorbackdata "$[infostore.monitorbackdata]+$[infostore.fvwmdesk.$[monitor.$[infostore.monitor8.name].desk].back]"
+ I Test (EnvIsSet infostore.monitor9.name) \
    InfoStoreAdd monitordata \
    "$[infostore.monitordata]+$[infostore.monitor9.data]/$[monitor.$[infostore.monitor9.name].desk]/$[infostore.fvwmdesk.$[monitor.$[infostore.monitor9.name].desk].backinfo]
+ I Test (EnvIsSet infostore.monitor9.name) \
    InfoStoreAdd monitorbackdata "$[infostore.monitorbackdata]+$[infostore.fvwmdesk.$[monitor.$[infostore.monitor9.name].desk].back]"
+ I Test (f $[FVWM_USERDIR]/backer/bgcache/$[infostore.monitordata]/$[infostore.monitorbackdata].png) \
    Exec exec fvwm-root -r $[FVWM_USERDIR]/backer/bgcache/$[infostore.monitordata]/$[infostore.monitorbackdata].png
+ I Test (!f $[FVWM_USERDIR]/backer/bgcache/$[infostore.monitordata]/$[infostore.monitorbackdata].png) \
    Exec exec $[NSCDE_ROOT]/libexec/xrandr_backer "$[infostore.monitordata]" "$[infostore.monitorbackdata]"

# Function: f_CleanupBackgroundCache
# Called by: Color Style Manager, Backdrop Style Manager
DestroyFunc f_CleanupBackgroundCache
AddToFunc f_CleanupBackgroundCache
+ I Test (f $[FVWM_USERDIR]/backer/bgcache) Exec exec find $[FVWM_USERDIR]/backer/bgcache -type f -exec rm -f {} \;

# Function: f_DeskLastPage
# Called if infostore.desklastpage is 1 from f_ChangePage and f_ChangeDesk
# Removes possibility of race condition and double execution.
# Takes no parameters
DestroyFunc f_DeskLastPage
AddToFunc f_DeskLastPage
+ I Test (EnvMatch infostore.desklastpage_done 1) Break
+ I InfoStoreAdd last_page_dsk_$[desk.n] "$[page.nx] $[page.ny]"
+ I InfoStoreAdd lpactive_$[desk.n] 1
+ I InfoStoreAdd desklastpage_done 1
+ I Schedule 100 InfoStoreAdd desklastpage_done 0

# Function: f_SysAddWindowEvent
# Called by: Module FvwmEvent aliased to MainLoop
DestroyFunc f_SysAddWindowEvent
AddToFunc f_SysAddWindowEvent
+ I Next (GlobalPager,!Transient) f_CenterWindow
+ I Any (CurrentPage,$[w.resource],$[w.class],State 2) Break
+ I WindowId $0 (!FixedSize,!FixedPosition,!State 2,!Transient) f_GetWinGeometry ResizeMove
+ I WindowId $0 (FixedSize) f_GetWinGeometry f_SafeFvwmCmd Move screen c | cut -d\' \' -f 3,4
+ I WindowId $0 (FixedPosition) f_GetWinGeometry f_SafeFvwmCmd Resize | cut -d\' \' -f 1,2
+ I WindowId $0 (CurrentPage,$[w.resource],$[w.class]) WindowStyle State 2
+ I f_AddWindowEvent $0

# Function: f_SysConfigureWindowEvent
# Called by: Module FvwmEvent aliased to MainLoop
# Intended for selection hilighting of the subpanel Front Panel launchers, but functionality
# moved to f_SysMapEvent. Now used as last fallback mechanism for putting de-maximized
# windows into State 8 to get sane dynamic window operations menu
DestroyFunc f_SysConfigureWindowEvent
AddToFunc f_SysConfigureWindowEvent
+ I Schedule 920 WindowId $0 (!Maximized, Maximizable, !State 8) f_StatefulRestoreMaximize 8 9 10 11 2 Nop
+ I f_ConfigureWindowEvent $0

DestroyFunc f_SysDestroyWindowEvent
AddToFunc f_SysDestroyWindowEvent
+ I Nop
+ I f_DestroyWindowEvent $0

# Function: f_SysMapEvent
# Called by: Module FvwmEvent aliased to MainLoop
# Intended for selection hilighting of the subpanel Front Panel launchers
DestroyFunc f_SysMapEvent
AddToFunc f_SysMapEvent
+ I Test (!EnvMatch infostore.no_fp_colorset_change 1) WindowId $0 (NsCDE-Subpanel*) f_FrontPanelActionStyler $[w.resource] M1 17
+ I f_MapEvent $0

# Called from FvwmEvent MainLoop on "res_class" window manager event.
# This was the least resource triggering and consuming place to put
# Icon and MiniIcon search routines. Can be used for other things in
# the future.
DestroyFunc f_SysResClassEvent
AddToFunc f_SysResClassEvent
+ I InfoStoreAdd iconfile $[w.iconfile]
+ I InfoStoreAdd miniiconfile $[w.miniiconfile]
+ I Test (EnvMatch infostore.iconfile $[NSCDE_ROOT]/share/icons/NsCDE/Noicon.xpm) \
 f_FindIcon $0 $[w.resource]
+ I Test (EnvMatch infostore.miniiconfile $[NSCDE_ROOT]/share/icons/NsCDE/Nominiicon.xpm) \
 f_FindMiniIcon $0 $[w.resource]
+ I InfoStoreRemove iconfile
+ I InfoStoreRemove miniiconfile

# Function: f_FocusChange
# Called from FvwmEvent(1) on focus change
# Serves Style Manager, was serving FrontPanel before
# but now FrontPanel is handled by f_EnterWindow and
# f_LeaveWindow (enter_window and leave_window events
# of the FvwmEvent(1), not by focus_change event).
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_FocusChange
AddToFunc f_FocusChange
+ I f_ChangeIconFocus $0
+ I InfoStoreAdd focus_winname_old "$[infostore.focus_winname_current]"
+ I InfoStoreAdd focus_winname_current $[w.resource]
# + I Test (EnvMatch infostore.focus_winname_old FrontPanel) f_ClearFrontPanelPressed
# + I Test (EnvMatch infostore.focus_winname_current FrontPanel) f_PutFrontPanelPressed
+ I Test (EnvMatch infostore.focus_winname_old "StyleMgr") SendToModule StyleMgr SendString 6 2 hideframe
+ I Test (EnvMatch infostore.focus_winname_current "StyleMgr") SendToModule StyleMgr SendString 6 2 showframe
+ I All (FrontPanel, CirculateHit, !HasPointer) SendToModule $[infostore.WSM] SendString 30 2 unselect

# Function: f_ChangeIconFocus
# Called from f_FocusChange which is called from FvwmEvent(1)
DestroyFunc f_ChangeIconFocus
AddToFunc f_ChangeIconFocus
# Parameters: $0 - Window (Icon) ID from FvwmEvent(1)
+ I WindowId $0 (Iconic, Focused, !State 3, !State 4) WindowStyle IconBackgroundColorset 19
+ I WindowId $0 (Iconic, Focused, State 3) WindowStyle IconBackgroundColorset 55
+ I WindowId $0 (Iconic, Focused, State 4) WindowStyle IconBackgroundColorset 57
+ I WindowId $[infostore.lastfocusedicon] (Iconic, !Focused, !State 3, !State 4) WindowStyle IconBackgroundColorset 18
+ I WindowId $[infostore.lastfocusedicon] (Iconic, !Focused, State 3) WindowStyle IconBackgroundColorset 54
+ I WindowId $[infostore.lastfocusedicon] (Iconic, !Focused, State 4) WindowStyle IconBackgroundColorset 56
+ I InfoStoreAdd lastfocusedicon $0

# Function f_EnterWindow 
# Called by the FvwmEvent(1) on enter_window event.
# Currently serves FrontPanel to make it appear as MouseFocus instead of ClickToFocus.
# and to lower/raise FrontPanel in and out of the way during the work.
# Has also user function place holder call on the end.
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_EnterWindow
AddToFunc f_EnterWindow
+ I WindowId $0 (FrontPanel, !Iconic) f_FrontPanelVisualFocus 2 f_PutFrontPanelPressed 0
+ I WindowId $0 (Gkrellm, !Gkrellm_conf, !Iconic, CirculateHit) f_ToggleWindowStyle BorderColorset 2
+ I f_AutoLower FrontPanel 2800
+ I f_AutoRaise FrontPanel 400
+ I f_UserEnterWindow $0

# Function f_LeaveWindow 
# Called by the FvwmEvent(1) on leave_window event.
# Currently serves FrontPanel to make it appear as
# MouseFocus instead of ClickToFocus.
# Has also user function place holder call on the end.
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_LeaveWindow
AddToFunc f_LeaveWindow
+ I WindowId $0 (FrontPanel, !Iconic) f_FrontPanelVisualFocus 1 f_ClearFrontPanelPressed 1
+ I f_UserLeaveWindow $0

# Function: f_IconifyWindow
# Called from FvwmEvent MainLoop instance when window is
# iconified. Initial purpose: change pixmap/colorset for
# icons bigger than cca 60x60.
DestroyFunc f_IconifyWindow
AddToFunc f_IconifyWindow
+ I PipeRead "echo '$[ip.width]$[ip.height]' | egrep -q '^[0-9]+$' || echo 'Break 1'"
+ I PipeRead "/usr/bin/env ksh93 -c '(( $[ip.width] > 60 && $[ip.width] < 72 || $[ip.height] > 60 && $[ip.height] < 72 )) && \
 echo \"WindowId $0 WindowStyle State 3, IconBackgroundColorset 54\"'"
+ I PipeRead "/usr/bin/env ksh93 -c '(( $[ip.width] >= 72 || $[ip.height] >= 72 )) &&  \
 echo \"WindowId $0 WindowStyle State 4, IconBackgroundColorset 56\"'"
+ I None (CurrentPage, !CirculateHit, Iconifiable, !Iconic) \
 InfoStoreAdd sdpstat-$[pointer.screen]$[desk.n]$[page.nx]$[page.ny] restore

# Function: f_DeiconifyWindow
# Called from FvwmEvent MainLoop instance when window is deiconified.
# Not used currently
DestroyFunc f_DeiconifyWindow
AddToFunc f_DeiconifyWindow
+ I Nop

################################
# Functions for generating menus
################################

# Function: f_DeiconifyOnPageMenu
# Generates m_DeiconifyOnPage menu for icons
# which is called from m_IconOps icon menu.
DestroyFunc f_DeiconifyOnPageMenu
AddToFunc f_DeiconifyOnPageMenu
+ I f_SetWSMConf
+ I PipeRead "$NSCDE_ROOT/bin/mkpagemenu $[infostore.pagematrixX] $[infostore.pagematrixY] menu_noicons f_DeiconifyOnPage"

# Top part of the window options menu
DestroyFunc f_WindowOpsBasic
AddToFunc f_WindowOpsBasic
+ I $1 $0 "$[gt.Re&position]		$[infostore.km_reposwin]" f_RepositionWindow
+ I AddToMenu $0 "$[gt.&Refresh]		$[infostore.km_regenwin]" f_RegenerateWindow
+ I AddToMenu $0 "$[gt.&Move]		$[infostore.km_move]" Move
+ I AddToMenu $0 "$[gt.&Size]		$[infostore.km_resize]" f_StatefulResize

# Static window options for static menus
DestroyFunc f_WindowOpsBasicNoCtx
AddToFunc f_WindowOpsBasicNoCtx
+ I AddToMenu $0 "$[gt.(De)&Iconify]		$[infostore.km_iconify]" Iconify
+ I AddToMenu $0 "$[gt.(De)S&hade]		$[infostore.km_windowshade]" WindowShade
+ I AddToMenu $0 "$[gt.Ma&ximize]		$[infostore.km_max_100]" f_StatefulRestoreMaximize 11 10 9 8 2 Maximize ewmhiwa true
+ I AddToMenu $0 "$[gt.Stre&tch]		$[infostore.km_max_101]" f_StatefulRestoreMaximize 10 9 8 11 2 Maximize true
+ I AddToMenu $0 "$[gt.&Grow]		$[infostore.km_max_88]" f_StatefulRestoreMaximize 9 11 10 8 2 Maximize grow grow
+ I AddToMenu $0 "$[gt.R&estore]		$[infostore.km_max_100]" f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I AddToMenu $0 "$[gt.Raise or &Lower]		$[infostore.km_raiselower]" RaiseLower

# Dynamic window options for static menus
DestroyFunc f_WindowOpsBasicCtx
AddToFunc f_WindowOpsBasicCtx
+ I ThisWindow (!Iconic, CirculateHit) \
    AddToMenu $0 "$[gt.&Iconify]		$[infostore.km_iconify]" Iconify
+ I ThisWindow (!Shaded, CirculateHit) \
    AddToMenu $0 "$[gt.S&hade]		$[infostore.km_windowshade]" WindowShade
+ I ThisWindow (Shaded, CirculateHit) \
    AddToMenu $0 "$[gt.Des&hade]		$[infostore.km_windowshade]" WindowShade
+ I ThisWindow (!Maximized, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.&Grow]		$[infostore.km_max_88]" f_StatefulRestoreMaximize 9 11 10 8 2 Maximize grow grow
+ I ThisWindow (!Maximized, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.Stre&tch]		$[infostore.km_max_101]" f_StatefulRestoreMaximize 10 9 8 11 2 Maximize true
+ I ThisWindow (!Maximized, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.Ma&ximize]		$[infostore.km_max_100]" f_StatefulRestoreMaximize 11 10 9 8 2 Maximize ewmhiwa true
+ I ThisWindow (State 9, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.Stre&tch]		$[infostore.km_max_88]" f_StatefulRestoreMaximize 10 9 8 11 2 Maximize true
+ I ThisWindow (State 9, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.Ma&ximize]		$[infostore.km_max_101]" f_StatefulRestoreMaximizeJump
+ I ThisWindow (State 9, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.R&estore]		$[infostore.km_max_100]" f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I ThisWindow (State 10, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.&Grow]		$[infostore.km_max_100]" f_GoFromMaxToGrow f_StatefulRestoreMaximize 9 11 10 8 2 Maximize grow grow
+ I ThisWindow (State 10, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.Ma&ximize]		$[infostore.km_max_88]" f_StatefulRestoreMaximize 11 10 9 8 2 Maximize ewmhiwa true
+ I ThisWindow (State 10, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.R&estore]		$[infostore.km_max_0]" f_StatefulRestoreMaximizeJump
+ I ThisWindow (State 11, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.&Grow]		$[infostore.km_max_0]" f_GoFromMaxToGrow f_StatefulRestoreMaximize 9 11 10 8 2 Maximize grow grow
+ I ThisWindow (State 11, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.Stre&tch]		$[infostore.km_max_100]" f_StatefulRestoreMaximize 10 9 8 11 2 Maximize true
+ I ThisWindow (State 11, Maximizable, CirculateHit) \
    AddToMenu $0 "$[gt.R&estore]		$[infostore.km_max_88]" f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I ThisWindow (Maximized, Maximizable, CirculateHit, !State 8, !State 9, !State 10, !State 11) \
    AddToMenu $0 "$[gt.R&estore]		$[infostore.km_max_0]" f_StatefulRestoreMaximize 8 9 10 11 2 Maximize false
+ I ThisWindow (!Overlapped, CirculateHit) \
    AddToMenu $0 "$[gt.&Lower]		$[infostore.km_raiselower]" RaiseLower
+ I ThisWindow (Overlapped, CirculateHit) \
    AddToMenu $0 "$[gt.R&aise]		$[infostore.km_raiselower]" RaiseLower

# Dynamic icon options for static menus
DestroyFunc f_IconOpsBasicCtx
AddToFunc f_IconOpsBasicCtx
+ I DestroyMenu recreate $0
+ I ThisWindow (Iconic, CirculateHit) AddToMenu $0 "$[gt.De&iconify]		$[infostore.km_iconify]" Iconify Off
+ I Test (!EnvMatch infostore.pgm 1x1) AddToMenu $0 "$[gt.Deiconify On Page ...]" Popup m_DeiconifyOnPage
+ I AddToMenu $0 "" Nop
+ I AddToMenu $0 "$[gt.&Move]		$[infostore.km_move]" Move
+ I ThisWindow (!Overlapped, Iconic, CirculateHit) AddToMenu $0 "$[gt.&Lower]		$[infostore.km_raiselower]" RaiseLower
+ I ThisWindow (Overlapped, Iconic, CirculateHit) AddToMenu $0 "$[gt.R&aise]		$[infostore.km_raiselower]" RaiseLower
+ I AddToMenu $0 "" Nop
+ I AddToMenu $0 "$[gt.I&dentify]		$[infostore.km_identify]" Module FvwmIdent
+ I AddToMenu $0 "" Nop
+ I Test (EnvMatch infostore.desknum 1) f_WindowOpsClosable $0
+ I Test (EnvMatch infostore.desknum 1) Break 1
+ I AddToMenu $0 "$[gt.&Occupy Workspace...]		$[infostore.km_occupyworkspace]" None (Occupy) Current f_SendToOccupy wsp nogo
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.&Occupy Monitor...]		$[infostore.km_occupymonitor]" None (Occupy) Current f_SendToOccupy mon nogo
+ I ThisWindow (!StickyAcrossDesks, CirculateHit) AddToMenu $0 "$[gt.&Occupy All Workspaces]" StickAcrossDesks True
+ I ThisWindow (StickyAcrossDesks, CirculateHit) AddToMenu $0 "$[gt.&Unoccupy All Workspaces]" StickAcrossDesks False
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsClosable $0

# Part of the window options menu: moving window on workspaces and pages
DestroyFunc f_WindowOpsOccupy
AddToFunc f_WindowOpsOccupy
+ I AddToMenu $0 "$[gt.&Occupy Workspace...]		$[infostore.km_occupyworkspace]" f_SendToOccupy wsp nogo
+ I Test (!EnvMatch infostore.pgm 1x1) AddToMenu $0 "$[gt.&Occupy Page...]		$[infostore.km_occupypage]" f_SendToOccupy pg nogo
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.&Occupy Monitor...]		$[infostore.km_occupymonitor]" f_SendToOccupy mon nogo
+ I ThisWindow (!Sticky, CirculateHit) AddToMenu $0 "$[gt.&Occupy All]		$[infostore.km_sticktoggle]" Stick True
+ I ThisWindow (StickyAcrossDesks, CirculateHit) AddToMenu $0 "$[gt.&Unoccupy All Workspaces]		$[infostore.km_stickwspacetoggle]" StickAcrossDesks False
+ I ThisWindow (StickyAcrossPages, CirculateHit) AddToMenu $0 "$[gt.&Unoccupy All Pages]		$[infostore.km_stickpagetoggle]" StickAcrossPages False
+ I ThisWindow (StickyAcrossDesks, StickyAcrossPages, CirculateHit) AddToMenu $0 "$[gt.&Unoccupy All]		$[infostore.km_sticktoggle]" Stick False

# Extend window options menu
DestroyFunc f_WindowOpsMore
AddToFunc f_WindowOpsMore
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Extended Menu ...]" Menu m_WindowOpsExtended Context 0+4p o+5
+ I Test (!EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Extended Menu ...]" Menu m_WindowOpsExtended This 0 0

# Reduce extended window options menu to standard menu back
DestroyFunc f_WindowOpsLess
AddToFunc f_WindowOpsLess
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Standard Menu ...]" Menu m_WindowOpsStandard Context 0+4p o+4
+ I Test (!EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Standard Menu ...]" Menu m_WindowOpsStandard This 0 0
+ I AddToMenu $0 "" Nop

# Close window actions: part of the window options menus
DestroyFunc f_WindowOpsClosable
AddToFunc f_WindowOpsClosable
+ I AddToMenu $0 "$[gt.&Close]		$[infostore.km_close]" Close
+ I AddToMenu $0 "$[gt.&Forcefully Close]		$[infostore.km_destroy]" Destroy

# Extended additions for window options menus
DestroyFunc f_WindowOpsExtended
AddToFunc f_WindowOpsExtended
+ I AddToMenu $0 "$[gt.Window Layers] ..." Popup m_WindowLayers
+ I AddToMenu $0 "$[gt.I&dentify]		$[infostore.km_identify]" Module FvwmIdent
+ I AddToMenu $0 "$[gt.Save &Geometry ...]		$[infostore.km_savegeom]" f_SaveGeometry
+ I AddToMenu $0 "$[gt.Title &Bar On/Off]		$[infostore.km_toggletitle]" Pick (CirculateHit) f_ToggleWindowStyle Title
+ I AddToMenu $0 "$[gt.&Center Window]			$[infostore.km_centerwindow]" Pick (CirculateHit) f_CenterWindow
+ I $1 $0 "$[gt.&Full Screen]			$[infostore.km_fullscreen]" Pick (CirculateHit) Maximize fullscreen

# Function which generates first button on titlebar window options menu
DestroyFunc f_StandardWindowMenu
AddToFunc f_StandardWindowMenu
+ I DestroyMenu recreate $0
+ I f_WindowOpsBasic $0 AddToMenu
+ I f_WindowOpsBasicCtx $0
+ I AddToMenu $0 "" Nop
+ I Test (!EnvMatch infostore.desknum 1) f_WindowOpsOccupy $0
+ I Test (!EnvMatch infostore.desknum 1) AddToMenu $0 "" Nop
+ I f_WindowOpsMore $0
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsClosable $0
+ I Current f_ExtendCtxMenu1 $0 $[w.class] $[w.resource]

# Function which generates first button on titlebar window options menu
# Extended version activated with "More ..." on Standard window options menu
DestroyFunc f_ExtendedWindowMenu
AddToFunc f_ExtendedWindowMenu
+ I DestroyMenu recreate $0
+ I f_WindowOpsBasic $0 AddToMenu
+ I f_WindowOpsBasicCtx $0
+ I AddToMenu $0 "" Nop
+ I Test (!EnvMatch infostore.desknum 1) f_WindowOpsOccupy $0
+ I Test (!EnvMatch infostore.desknum 1) AddToMenu $0 "" Nop
+ I f_WindowOpsLess $0
+ I f_WindowOpsExtended $0 "ThisWindow (CirculateHit, Maximizable) AddToMenu"
+ I AddToMenu $0 "" Nop
+ I f_WindowOpsClosable $0
+ I Current f_ExtendCtxMenu2 $0 $[w.class] $[w.resource]

# Function which generates first button on titlebar of subpanel window options menu
DestroyFunc f_SubpanelWindowMenu
AddToFunc f_SubpanelWindowMenu
+ I DestroyMenu recreate $0
+ I AddToMenu $0 "$[gt.&Refresh]		$[infostore.km_regenwin]" f_RegenerateWindow
+ I AddToMenu $0 "$[gt.&Move]		$[infostore.km_move]" Move
+ I AddToMenu $0 "$[gt.&Size]		$[infostore.km_resize]" Resize fixeddirection East
+ I f_WindowOpsBasicCtx $0 Nop
+ I AddToMenu $0 "" Nop
+ I AddToMenu $0 "$[gt.Reload Subpanel]" Current f_RefreshSubpanel $[w.resource]
+ I AddToMenu $0 "$[gt.Subpanel Settings]" Current Module FvwmScript SubpanelSettings $[w.resource]

# Special window options menu function for Front Panel
DestroyFunc f_WindowOpsFPBtn1
AddToFunc f_WindowOpsFPBtn1
+ I DestroyMenu recreate $0
+ I f_WindowOpsBasic $0 Nop
+ I AddToMenu $0 "$[gt.Reposi&tion]		$[infostore.km_raisefp]" f_RestoreFrontPanel WindowShade Off
+ I AddToMenu $0 "$[gt.&Iconify]		$[infostore.km_iconify]" Iconify
+ I ThisWindow (!Shaded, CirculateHit) AddToMenu $0 "$[gt.S&hade]		$[infostore.km_raiseshadefp]" f_RestoreFrontPanel WindowShade South
+ I ThisWindow (!Overlapped, CirculateHit) AddToMenu $0 "$[gt.&Lower]		$[infostore.km_raiselower]" RaiseLower
+ I ThisWindow (Overlapped, CirculateHit) AddToMenu $0 "$[gt.R&aise]		$[infostore.km_raiselower]" RaiseLower
+ I AddToMenu $0 "" Nop
+ I AddToMenu $0 "$[gt.&Occupy Workspace...]		$[infostore.km_occupyworkspace]" f_SendToOccupy wsp nogo
+ I Test (!EnvMatch infostore.pgm 1x1) AddToMenu $0 "$[gt.&Occupy Page...]		$[infostore.km_occupypage]" f_SendToOccupy pg nogo
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.&Occupy Monitor...]		$[infostore.km_occupymonitor]" f_SendToOccupy mon nogo
+ I ThisWindow (!Sticky, CirculateHit) AddToMenu $0 "$[gt.&Occupy All Workspaces]		$[infostore.km_sticktoggle]" Stick True
+ I ThisWindow (Sticky, CirculateHit) AddToMenu $0 "$[gt.&Unoccupy All Workspaces]		$[infostore.km_sticktoggle]" Stick False
+ I AddToMenu $0 "" Nop
+ I AddToMenu $0 "$[gt.Front Panel Controls]"		Menu m_ControlFrontPanelMenu Window o+0+5p -100m+5p
+ I AddToMenu $0 "$[gt.&Close Front Panel]		$[infostore.km_delete]" Current f_CloseFrontPanel $[w.id]

# Right click on Front Panel menu handle
DestroyFunc f_WindowOpsFPHandle
AddToFunc f_WindowOpsFPHandle
+ I DestroyMenu recreate $0
+ I AddToMenu $0 "$[gt.&Move]"	Move
+ I AddToMenu $0 "$[gt.&Iconify]"	Iconify
+ I ThisWindow (!Overlapped, CirculateHit) AddToMenu $0 "$[gt.&Lower]" RaiseLower
+ I ThisWindow (Overlapped, CirculateHit) AddToMenu $0 "$[gt.R&aise]" RaiseLower
+ I AddToMenu $0 "$[gt.&Refresh]"	f_RegenerateWindow
+ I AddToMenu $0 "$[gt.Reposi&tion]"	f_RestoreFrontPanel WindowShade Off
+ I AddToMenu $0 "" Nop
+ I AddToMenu $0 "$[gt.Lo&g out ...]"	f_RunQuickScriptDialog SysActionDialog 1

# Fill Applications Menu:
# If there is APPMENU env set, use this as the desktop menu
# If not, check for XDG_CURRENT_DESKTOP, lowercase and use that
# If not, use "--desktop nscde" while generating menus to get
# proper default nscde menu.
DestroyFunc f_ApplicationsMenu
AddToFunc f_ApplicationsMenu
+ I Test (EnvIsSet APPMENU) \
    PipeRead "fvwm-menu-desktop -e --enable-mini-icons \
    --theme NsCDE --insert-in-menu m_Applications --include-items none \
    --app-icon ${NSCDE_ROOT}/share/icons/NsCDE/Nominiicon.xpm --menu-type applications \
    --desktop $[APPMENU] --mini-icon-dir ${FVWM_USERDIR}/icons | uniq
+ I TestRc (Match) Break
+ I Test (EnvIsSet XDG_CURRENT_DESKTOP, !EnvMatch XDG_CURRENT_DESKTOP "") \
    PipeRead 'echo $(echo "SetEnv APPMENU "; echo $(echo $XDG_CURRENT_DESKTOP | tr A-Z a-z))'
+ I Test (EnvIsSet APPMENU) \
    PipeRead "fvwm-menu-desktop -e --enable-mini-icons \
    --theme NsCDE --insert-in-menu m_Applications --include-items none \
    --app-icon ${NSCDE_ROOT}/share/icons/NsCDE/Nominiicon.xpm --menu-type applications \
    --desktop $[APPMENU] --mini-icon-dir ${FVWM_USERDIR}/icons | uniq
+ I TestRc (Match) Break
+ I TestRc (NoMatch) \
    PipeRead "fvwm-menu-desktop -e --enable-mini-icons \
    --theme NsCDE --insert-in-menu m_Applications --include-items none \
    --app-icon ${NSCDE_ROOT}/share/icons/NsCDE/Nominiicon.xpm --menu-type applications \
    --desktop nscde --mini-icon-dir ${FVWM_USERDIR}/icons | uniq
 
DestroyFunc f_IconOps
AddToFunc f_IconOps
+ C Menu m_IconOps Icon +0 -100m Iconify False
+ M Move

# Root Menu small function placeholder for
# double click handling of mouse on root window.
DestroyFunc f_RootMenu
AddToFunc f_RootMenu
+ D Menu m_WindowOpsRootWin -2m -2m
+ C Test (EnvMatch infostore.sandboxmode 0) Menu m_RootMenu mouse -2m -2m
+ C Test (EnvMatch infostore.sandboxmode 1) Menu m_SandboxRootMenu mouse -2m -2m
+ I Test (EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Standard Menu ...]" Menu m_WindowOpsStandard Context 0+4p o+4
+ I Test (!EnvMatch infostore.lscrn.sls 1) AddToMenu $0 "$[gt.Standard Menu ...]" Menu m_WindowOpsStandard This 0 0
+ I AddToMenu $0 "" Nop

DestroyFunc f_ControlFrontPanelMenu
AddToFunc f_ControlFrontPanelMenu
+ I DestroyMenu recreate m_ControlFrontPanelMenu
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Front Panel Controls]" Title
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Manage Workspaces and Pages]" f_ToggleFvwmFunc WsPgMgr Close f_RunQuickScriptDialog WsPgMgr $[infostore.desknum] $[infostore.pagematrixX] $[infostore.pagematrixY]
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Restart Workspace Manager]" KillModule FvwmScript $[infostore.WSM]
+ I AddToMenu m_ControlFrontPanelMenu "" Nop
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Number of Launchers ...]" Popup m_CtrlFPLaunchers
+ I AddToMenu m_ControlFrontPanelMenu "" Nop
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Restart Front Panel Clock]" Exec exec pkill -U $LOGNAME pclock
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Restart Front Panel Mail]" KillModule FvwmScript CheckMailApplet
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Restart Front Panel Date]" KillModule FvwmScript MonthDayApplet
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Restart Front Panel Lite]" KillModule FvwmScript FpLite
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Restart Front Panel]" f_RestartFrontPanel
+ I AddToMenu m_ControlFrontPanelMenu "" Nop
+ I AddToMenu m_ControlFrontPanelMenu "$[gt.Help]" f_DisplayURL "$[gt.Front Panel Help]" file://$[NSCDE_ROOT]/share/doc/html/NsCDE-applets-docks-panels.html#NsCDE-FrontPanel

DestroyFunc f_CtrlFPLaunchers
AddToFunc f_CtrlFPLaunchers
+ I DestroyMenu recreate m_CtrlFPLaunchers
+ I Test (!EnvMatch infostore.FP.LeftLaunchersNum 10) AddToMenu m_CtrlFPLaunchers "$[gt.Add Left Launcher]" f_AddRemoveLauncher -A Left
+ I Test (!EnvMatch infostore.FP.RightLaunchersNum 10) AddToMenu m_CtrlFPLaunchers "$[gt.Add Right Launcher]" f_AddRemoveLauncher -A Right
+ I AddToMenu m_CtrlFPLaunchers "" Nop
+ I Test (!EnvMatch infostore.FP.LeftLaunchersNum 0) AddToMenu m_CtrlFPLaunchers "$[gt.Remove Left Launcher]" f_AddRemoveLauncher -D Left
+ I Test (!EnvMatch infostore.FP.RightLaunchersNum 0) AddToMenu m_CtrlFPLaunchers "$[gt.Remove Right Launcher]" f_AddRemoveLauncher -D Right
+ I AddToMenu m_CtrlFPLaunchers "" Nop
+ I AddToMenu m_CtrlFPLaunchers "$[gt.Help]" f_DisplayURL "$[gt.Front Panel Help]" file://$[NSCDE_ROOT]/share/doc/html/NsCDE-applets-docks-panels.html#NsCDE-FrontPanelNrOofLaunchers

DestroyFunc f_FrontPanelLockMenu
AddToFunc f_FrontPanelLockMenu
+ I DestroyMenu recreate m_FrontPanelLockMenu
+ I AddToMenu m_FrontPanelLockMenu " $[gt.Lock] " Title
+ I Test (EnvMatch infostore.nscde_use_xscreensaver 0) AddToMenu m_FrontPanelLockMenu "$[gt.(Disabled)]" Nop
+ I Test (EnvMatch infostore.nscde_use_xscreensaver 0) Break 1
+ I AddToMenu m_FrontPanelLockMenu "$[gt.&Lock Display]" Test (x xscreensaver) f_Xscreensaver -lock
+ I Test (!EnvMatch infostore.xsc_status "Alck_disabledO") AddToMenu m_FrontPanelLockMenu "$[gt.&Suspend Screensaver]" Test (x xscreensaver) f_Xscreensaver -stop
+ I Test (!EnvMatch infostore.xsc_status "Alck_enabledO") AddToMenu m_FrontPanelLockMenu "$[gt.&Resume Screensaver]" Test (x xscreensaver) f_Xscreensaver -cont
+ I AddToMenu m_FrontPanelLockMenu "" Nop
+ I AddToMenu m_FrontPanelLockMenu "$[gt.&Help]" Exec exec $[infostore.terminal] -e "man xscreensaver"

DestroyFunc f_ShowFPPGMenu
AddToFunc f_ShowFPPGMenu
+ I SendToModule FrontPanel PressButton FpPGM
+ I Test (EnvMatch infostore.pageshowrootpager 1, !EnvMatch infostore.pgm 1x1) \
  f_ShowLocalPager Move screen c 50-50w 50-50w ewmhiwa

#######################################################
# Placeholders for functions aimed for user to override
#######################################################
# Called from the CheckMailApplet (left from the WSM on Front Panel)
DestroyFunc f_CheckMail
AddToFunc f_CheckMail
+ I None ("NsCDE-Notifier.f_CheckMail") f_Notifier \
    "Check Mail Function" "Dismiss" "NsCDE/Info.xpm" \
    "$[gt.Write your f_CheckMail function in] $[FVWM_USERDIR]/NsCDE-Functions.local." "f_CheckMail"

# Called from MonthDayApplet (right of the watch on Front Panel)
DestroyFunc f_Calendar
AddToFunc f_Calendar
+ I None ("NsCDE-Notifier.f_Calendar") f_Notifier \
 "Calendar Function" "Dismiss" "NsCDE/Info.xpm" \
 "$[gt.Write your f_Calendar function in] $[FVWM_USERDIR]/NsCDE-Functions.local." "f_Calendar"

# Currently unused.
DestroyFunc f_Mixer
AddToFunc f_Mixer
+ I Test (!x pactl) None ("Audio Mixer Function") f_Notifier \
    "Audio Mixer Function" "Dismiss" "NsCDE/Info.xpm" \
    "$[gt.Write your f_Mixer function in] $[FVWM_USERDIR]/NsCDE-Functions.local."
+ I Test (!x pactl) Break 1
+ I InfoStoreAdd mixeraction $0
+ I Test (EnvMatch infostore.mixeraction -mute) \
    Exec exec pactl set-sink-mute @DEFAULT_SINK@ toggle
+ I Test (EnvMatch infostore.mixeraction -raise) \
    Exec exec pactl set-sink-volume @DEFAULT_SINK@ +$1%
+ I Test (EnvMatch infostore.mixeraction -lower) \
    Exec exec pactl set-sink-volume @DEFAULT_SINK@ -$1%
+ I InfoStoreRemove mixeraction

# Find dialog of user choice
# Intended to be destroyed and recreated by the user
DestroyFunc f_Find
AddToFunc f_Find
+ I Nop

# Function place holder for user additions to root menu
DestroyFunc f_AddCustomToRootMenu
AddToFunc f_AddCustomToRootMenu
+ I Nop

# Called from FvwmEvent MainLoop. Here, user can set
# own hooks to be done when current desk changes.
DestroyFunc f_UserChangeDesk
AddToFunc f_UserChangeDesk
+ I Nop

# Called from FvwmEvent MainLoop. Here, user can set
# own hooks to be done when current page changes.
DestroyFunc f_UserChangePage
AddToFunc f_UserChangePage
+ I Nop

# Hook of the f_SysAddWindowEvent called from
# FvwmEvent on add_window event
DestroyFunc f_AddWindowEvent
AddToFunc f_AddWindowEvent
+ I Nop

# Hook of the f_SysConfigureWindowEvent called from
# FvwmEvent on configure_window event
DestroyFunc f_ConfigureWindowEvent
AddToFunc f_ConfigureWindowEvent
+ I Nop

# Hook of the f_SysMapEvent called from
# FvwmEvent on map event
DestroyFunc f_MapEvent
AddToFunc f_MapEvent
+ I Nop

# Hook of the f_SysDestroyWindowEvent called from
# FvwmEvent on destroy_window event
DestroyFunc f_DestroyWindowEvent
AddToFunc f_DestroyWindowEvent
+ I Nop

# Hook of the RestartFunction called when
# FVWM is restarted.
DestroyFunc f_UserRestartFunction
AddToFunc f_UserRestartFunction
+ I Nop

# Function: f_UserEnterWindow
# Called from f_EnterWindow on mouse hover (FvwmEvent)
# Dummy (Nop) hook intended for local user redefinition.
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_UserEnterWindow
AddToFunc f_UserEnterWindow
+ I Nop

# Function: f_UserLeaveWindow
# Called from f_LeaveWindow on mouse hover (FvwmEvent)
# Dummy (Nop) hook intended for local user redefinition.
# Parameters: $0 - Window ID from FvwmEvent(1)
DestroyFunc f_UserLeaveWindow
AddToFunc f_UserLeaveWindow
+ I Nop

# Intended for user modifications
DestroyFunc f_InitFunction
AddToFunc f_InitFunction
+ I Nop


#####################################
# Functions used in NsCDE FvwmScripts
#####################################

# Function: f_RunQuickScriptDialog
# Center $0 where $0 is a dialog
# Depends on f_AnimatedCenterWarp
# $1 and $2 are coordinates for WarpToWindow used by f_AnimatedCenterWarp
DestroyFunc f_RunQuickScriptDialog
AddToFunc f_RunQuickScriptDialog
+ I None ($0) Module FvwmScript $*
+ I Wait $0
+ I f_AnimatedCenterWarp $0 50 45

# Function: f_SendToOccupy
# Calls and sets up Occupy (Workspace and/or Page) Script with fvwm variables
DestroyFunc f_SendToOccupy
AddToFunc f_SendToOccupy
+ I All (Occupy, CurrentPage, Visible, CirculateHit) KillModule FvwmScript Occupy
+ I PipeRead "echo InfoStoreAdd pagesmenu \\\"$($NSCDE_ROOT/bin/mkpagemenu \
              $[infostore.pagematrixX] $[infostore.pagematrixY] pgname | \
              tr '\\n' '|' | sed 's/|$//g')\\\""
+ I PipeRead "/usr/bin/env ksh93 -c 'echo -ne \"InfoStoreAdd desksmenu \"; echo -ne \\\"; \
              for desk in {0..$[infostore.fvwmdesknum]}; \
              do echo -ne "$[desk.name${desk}]"; \
              [ ${desk} != $[infostore.fvwmdesknum] ] && \
              echo -ne \"|\"; done; echo -ne \\\"'"
+ I PipeRead "/usr/bin/env ksh93 -c 'echo -ne \"InfoStoreAdd monitorsmenu \"; \
              echo $[infostore.active.monitors] | tr \" \" \"|\"'
+ I Test (EnvMatch FVWM_IS_FVWM3 1) Module FvwmScript Occupy 3 $0 \
    $[desk.n] $[page.nx] $[page.ny] $[infostore.monitor.$[monitor.current].idx] $[infostore.desknum] $[infostore.pagematrixX] $[infostore.pagematrixY] $[monitor.count] $1
+ I Test (!EnvMatch FVWM_IS_FVWM3 1) Module FvwmScript Occupy 2 $0 \
    $[desk.n] $[page.nx] $[page.ny] $[pointer.screen] $[infostore.desknum] $[infostore.pagematrixX] $[infostore.pagematrixY] $[infostore.lscrn.cnt] $1
+ I Wait Occupy
+ I SendToModule Occupy SendString 1 1 $[infostore.desksmenu]
+ I SendToModule Occupy SendString 1 2 $[infostore.pagesmenu]
+ I SendToModule Occupy SendString 1 3 $[w.id]
+ I SendToModule Occupy SendString 1 7 $[infostore.monitorsmenu]

# Function: f_Occupy
# Called from Occupy Script
# $0 = Window Id
# $1 = MoveToDesk or MoveToPage
# $2 = Page or Desk X
# $3 = Page or Desk Y
# $4 = Place holder for GoToDesk and/or GoToPage
DestroyFunc f_Occupy
AddToFunc f_Occupy
+ I WindowId $0 Stick False
+ I WindowId $0 $1 $2 $3
+ I $4 $2 $3

# Without this, WSM does not change it's pressed/unpressed button state
# if desk is changed by some other means. Second SendString is for frame
# around active workspace button.
# Function f_SendToWSM
# WSM Helper
DestroyFunc f_SendToWSM
AddToFunc f_SendToWSM
+ I All (FrontPanel, CirculateHit, Screen $[pointer.screen]) SendToModule $[infostore.WSM] SendString 40 10 $[desk.n]$[page.nx]$[page.ny]
+ I All (FrontPanel, CirculateHit, HasPointer, Screen $[pointer.screen]) SendToModule $[infostore.WSM] SendString 30 2 unclick

# Unclick Page Manager from itself (visual function only)
# Function f_SendToPGM
# PGM Helper
DestroyFunc f_SendToPGM
AddToFunc f_SendToPGM
+ I All (FrontPanel, CirculateHit, Screen $[pointer.screen]) SendToModule FrontPanel ChangeButton FpPGM Icon \
    NsCDE/Wsm_$[infostore.pagematrixX]x$[infostore.pagematrixY]_$[page.nx]$[page.ny].xpm

# Function: f_SameWspActionForWSM
# Called by: Workspace Manager when current desk button is clicked
# Calls: f_ShowLocalPager
DestroyFunc f_SameWspActionForWSM
AddToFunc f_SameWspActionForWSM
+ I f_SendToWSM
+ I Test (EnvMatch infostore.pageshowrootpager 0) Break
+ I Current (FrontPanel, CirculateHit) All ("LocalPager") f_ShowLocalPager Move screen c 50-50w -88p ewmhiwa
+ I Current (FrontPanel, CirculateHit) All ("LocalPager", !State 6) WarpToWindow 25 95

# Fplite applet on Front Panel, right top of WSM
# Can be overriden by user if user has some fancy
# app for processes and system resources.
DestroyFunc f_FpLiteClickAction
AddToFunc f_FpLiteClickAction
+ I Test (EnvMatch NSCDE_OS SunOS) Exec exec $[infostore.terminal] -e prstat
+ I TestRc (Match) Break
+ I Test (EnvMatch NSCDE_OS AIX) Exec exec $[infostore.terminal] -e topas
+ I TestRc (Match) Break
+ I Test (x top) Exec exec $[infostore.terminal] -e top
+ I TestRc (Match) Break
+ I None ("FpLite Function Error") f_Notifier \
 "FpLite Function Error" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_FpLiteClickAction: Cannot find top(1), prstat(1m) or topas(5) in PATH] $[PATH]."

# SysActionDialog
DestroyFunc f_QuitAndExit
AddToFunc f_QuitAndExit
+ I Test (EnvIsSet SESSION_MANAGER) SetEnv QuitCmd SaveQuitSession
+ I Test (!EnvIsSet SESSION_MANAGER) SetEnv QuitCmd Quit
+ I Echo NsCDE: Quit X Session
+ I Test (!EnvIsSet SESSION_MANAGER) Deschedule
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 1200 $[QuitCmd]
+ I Test (EnvIsSet SESSION_MANAGER) Schedule 200 $[QuitCmd]

# SysActionDialog
DestroyFunc f_QuitAndShutdown
AddToFunc f_QuitAndShutdown
+ I Test (EnvIsSet SESSION_MANAGER) SetEnv QuitCmd SaveQuitSession
+ I Test (!EnvIsSet SESSION_MANAGER) SetEnv QuitCmd Quit
+ I Echo NsCDE: Quit and Shutdown
+ I Test (!EnvIsSet SESSION_MANAGER) Deschedule
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 1200 Exec exec /usr/bin/env ksh93 -c \
 "sudo -n $[NSCDE_ROOT]/libexec/nscde-acpi $0 || $[NSCDE_ROOT]/libexec/nscde-acpi $0"
+ I Test (!EnvIsSet SESSION_MANAGER) Schedule 1600 $[QuitCmd]
+ I Test (EnvIsSet SESSION_MANAGER) Exec exec /usr/bin/env ksh93 -c \
 "sudo -n $[NSCDE_ROOT]/libexec/nscde-acpi $0 || $[NSCDE_ROOT]/libexec/nscde-acpi $0"
+ I Test (EnvIsSet SESSION_MANAGER) Schedule 400 $[QuitCmd]

# Designed as self-helper for Fvwm Scripts
DestroyFunc f_UnclickScript
AddToFunc f_UnclickScript
+ I Schedule $0 SendToModule $1 SendString $2 $3 $4

# Temporary define InfoStore variable with removal timing
# Usage: f_InfoStoreTimeSet 5000 foo 1
DestroyFunc f_InfoStoreTimeSet
AddToFunc f_InfoStoreTimeSet
+ I InfoStoreAdd $1 $2
+ I Schedule $0 InfoStoreRemove $1

# Find XDG subdirectory from user and set it if found. If set but non-existent,
# set InfoStore variable for XDG subdirectory to $HOME.
# Parameters: $0 is one of DESKTOP, DOWNLOAD, TEMPLATES, PUBLICSHARE,
# DOCUMENTS, MUSIC, PICTURES and VIDEOS
DestroyFunc f_XdgUserDir
AddToFunc f_XdgUserDir
+ I Test (!x xdg-user-dir) InfoStoreAdd XDG_$0_DIR "$[HOME]"
+ I Test (!x xdg-user-dir) Break 1
+ I PipeRead '[ -d $(xdg-user-dir $0) ] && \
              echo InfoStoreAdd XDG_$0_DIR "$(xdg-user-dir $0)" || \
              echo InfoStoreAdd XDG_$0_DIR "$[HOME]"'

DestroyFunc f_NProcMgrHandler
AddToFunc f_NProcMgrHandler
+ I Test (EnvMatch infostore.$2 1) SendToModule NProcMgr SendString $0 $1 Enabled
+ I TestRc (Match) Break 1
+ I Test (EnvMatch infostore.$2 0) SendToModule NProcMgr SendString $0 $1 Disabled
+ I TestRc (Match) Break 1
+ I Test (!EnvMatch infostore.$2 0) SendToModule NProcMgr SendString $0 $1 Unknown

# Watch Errors (Xsession and FVWM3 Log)
DestroyFunc f_WatchErrors
AddToFunc f_WatchErrors
+ I f_ToggleExecWindow WatchWinMgrErrors UrgencyFunc xterm -title \"$[gt.Watch Errors]\" -name WatchWinMgrErrors -e $[infostore.xlogcmd]
+ I Test (EnvMatch FVWM_IS_FVWM3 1) Schedule 500 f_FvwmLogMgmt -enable

# FVWM3 Log management: prepare, enable, disable or toggle actions
DestroyFunc f_FvwmLogMgmt
AddToFunc f_FvwmLogMgmt
+ I Test (!EnvMatch FVWM_IS_FVWM3 1) None ("NsCDE-Notifier.f_FvwmLogMgmt") f_Notifier \
 "FVWM3 Log Management" "Dismiss" "NsCDE/Error.xpm" \
 "$[gt.Error: Func:f_FvwmLogMgmt: This function is not available on FVWM] $[version.num]." "f_FvwmLogMgmt"
+ I Test (!EnvMatch FVWM_IS_FVWM3 1) Break 1
+ I Test (!f $[FVWM3_LOGFILE]) touch $[FVWM3_LOGFILE]
+ I InfoStoreRemove fvwmdebuglogstate
+ I InfoStoreAdd fvwmdebuglogstate "$[debuglog.state] $0"
+ I Test (EnvMatch infostore.fvwmdebuglogstate "0 -enable") Exec exec kill -USR2 $PPID
+ I Test (EnvMatch infostore.fvwmdebuglogstate "1 -disable") Exec exec kill -USR2 $PPID
+ I Test (EnvMatch infostore.fvwmdebuglogstate "0 -toggle") Exec exec kill -USR2 $PPID
+ I Test (EnvMatch infostore.fvwmdebuglogstate "1 -toggle") Exec exec kill -USR2 $PPID
+ I Schedule 500 f_FvwmLogState

# Helper of f_FvwmLogMgmt: sends debug log indication into titlebar of
# the Watch Errors window.
DestroyFunc f_FvwmLogState
AddToFunc f_FvwmLogState
+ I InfoStoreAdd fvwmdebuglogstate $[debuglog.state]
+ I Test (EnvMatch infostore.fvwmdebuglogstate 0) All (XTerm,WatchWinMgrErrors,CirculateHit) \
    WindowStyle TitleFormat %n ($[gt.FVWM3 Logging Disabled])
+ I Test (EnvMatch infostore.fvwmdebuglogstate 1) All (XTerm,WatchWinMgrErrors,CirculateHit) \
    WindowStyle TitleFormat %n ($[gt.FVWM3 Logging Enabled])

# Rofi support
DestroyFunc f_RofiSetup
AddToFunc f_RofiSetup
+ I Module FvwmScript WaitNotice "$[gt.Rofi]" "$[gt.Setting up NsCDE Rofi theme] $[NSCDE_PALETTE]" " $[gt.for the first use ...] " $0
+ I Exec exec mkdir -p $[FVWM_USERDIR]/tmp
+ I Test (f $[FVWM_USERDIR]/palettes/$[NSCDE_PALETTE].dp) \
    Exec exec $[NSCDE_ROOT]/libexec/nscde_palette_colorgen.py \
     -n $[NSCDE_PALETTE_NCOLORS] -p $[FVWM_USERDIR]/palettes/$[NSCDE_PALETTE].dp \
     -i $[NSCDE_ROOT]/share/config_templates/NsCDE-rasi.tmpl -s -c > $[FVWM_USERDIR]/tmp/NsCDE.rasi
+ I Test (!f $[FVWM_USERDIR]/palettes/$[NSCDE_PALETTE].dp) \
    Exec exec $[NSCDE_ROOT]/libexec/nscde_palette_colorgen.py \
     -n $[NSCDE_PALETTE_NCOLORS] -p $[NSCDE_ROOT]/share/palettes/$[NSCDE_PALETTE].dp \
     -i $[NSCDE_ROOT]/share/config_templates/NsCDE-rasi.tmpl -s -c > $[FVWM_USERDIR]/tmp/NsCDE.rasi
+ I PipeRead 'echo InfoStoreAdd rofi_def_font \\"$($NSCDE_ROOT/bin/getfont -v -t normal -s medium -p)\\"'
+ I PipeRead 'echo InfoStoreAdd rofi_mono_font \\"$($NSCDE_ROOT/bin/getfont -m -t normal -s medium -p)\\"'
+ I PipeRead 'echo InfoStoreAdd rofi_large_font \\"$($NSCDE_ROOT/bin/getfont -v -t normal -s large -p)\\"'
+ I Schedule 400 Exec exec $[NSCDE_ROOT]/bin/ised \
  -c 's/__ROFI_DEFAULT_FONT__/$[infostore.rofi_def_font]/g; s/__ROFI_MONO_FONT__/$[infostore.rofi_mono_font]/g; s/__ROFI_LARGE_FONT__/$[infostore.rofi_large_font]/g' \
  -f $[FVWM_USERDIR]/tmp/NsCDE.rasi
+ I Schedule 800 Exec exec mv -f $[FVWM_USERDIR]/tmp/NsCDE.rasi $[FVWM_USERDIR]/NsCDE.rasi
+ I InfoStoreRemove rofi_def_font
+ I InfoStoreRemove rofi_mono_font
+ I InfoStoreRemove rofi_large_font

# Call rofi with our theme
DestroyFunc f_Rofi
AddToFunc f_Rofi
+ I Test (f $[FVWM_USERDIR]/NsCDE.rasi) Exec exec rofi -theme $[FVWM_USERDIR]/NsCDE.rasi -show $0
+ I Test (f $[FVWM_USERDIR]/NsCDE.rasi) Break 1
+ I Test (!f $[FVWM_USERDIR]/NsCDE.rasi) f_RofiSetup 3200
+ I Test (!f $[FVWM_USERDIR]/NsCDE.rasi) Schedule 3200 Exec exec rofi -theme $[FVWM_USERDIR]/NsCDE.rasi -show $0

######################
# Upgrade Functions
######################

# Main upgrade caller
DestroyFunc f_Upgrade
AddToFunc f_Upgrade
+ I f_Upgrade_rc28

# rc28 - Colorset 23 for Front Panel to differ from static Colorset 21
DestroyFunc f_Upgrade_rc28
AddToFunc f_Upgrade_rc28
+ I Test (f "$[FVWM_USERDIR]/NsCDE-Colorset.conf") \
    PipeRead "egrep -q '^Colorset 23' "$[FVWM_USERDIR]/NsCDE-Colorset.conf" && echo Break 1"
+ I None ("NsCDE-Notifier.f_upgrade_rc28") f_Notifier \
    "$[gt.Important Upgrade Notice]" "Dismiss" "NsCDE/Info.xpm" \
    "$[gt.Changes in Colorsets for NsCDE version] 1.0rc28 \
$[gt.requires current color scheme to be re-applied for Front Panel to display properly.] \
$[gt.Please use Color Style Manager to select and confirm your color scheme.]" "f_upgrade_rc28"
+ I Schedule 2000 None (ColorMgr) Module FvwmScript ColorMgr $[desk.n] $[NSCDE_PALETTE_NCOLORS]

